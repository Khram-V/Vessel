//// GLUT + geometry rendering//#include <GL/gl.h>#include <Math.h>
#include <StdLib.h>
#define N( a,b,c ) glNormal3f( a,b,c )#define V( a,b,c ) glVertex3f( a size, b size, c size )static void Cube( const float &size )  { N( 1, 0, 0),V(+,+,+),V(+,-,+),V(+,-,-),V(+,+,-);    N( 0, 1, 0),V(+,+,+),V(+,+,-),V(-,+,-),V(-,+,+);    N( 0, 0, 1),V(+,+,+),V(-,+,+),V(-,-,+),V(+,-,+);    N( 0,-1, 0),V(+,-,+),V(-,-,+),V(-,-,-),V(+,-,-);    N( 0, 0,-1),V(-,-,-),V(-,+,-),V(+,+,-),V(+,-,-);    N(-1, 0, 0),V(-,-,-),V(-,-,+),V(-,+,+); // или лишняя точка V(+,+,-)  }void glutWireCube( float size ){ glBegin( GL_LINE_LOOP ); Cube( size/2 ); glEnd(); }void glutSolidCube( float size ){ glBegin( GL_QUADS ); Cube( size/=2 ); V(-,+,-); glEnd(); }#undef V#define V( a,b,c ) glVertex3f( a,b,c )
#define W( v ) glVertex3fv( v )
#define M( v ) glNormal3fv( v )
#define R 0.70710678118654752440 // M_SQRT1_2#define H 0.577350269189void drawSolidCuboctahedron(){ glBegin( GL_TRIANGLES );    N( H, H, H ),V( R, R,0 ),V( 0, R, R ),V( R, 0, R );    N( H, H,-H ),V( R, R,0 ),V( R, 0,-R ),V( 0, R,-R );    N( H,-H, H ),V( R,-R,0 ),V( R, 0, R ),V( 0,-R, R );    N( H,-H,-H ),V( R,-R,0 ),V( 0,-R,-R ),V( R, 0,-R );    N(-H, H, H ),V(-R, R,0 ),V(-R, 0, R ),V( 0, R, R );    N(-H, H,-H ),V(-R, R,0 ),V( 0, R,-R ),V(-R, 0,-R );    N(-H,-H, H ),V(-R,-R,0 ),V( 0,-R, R ),V(-R, 0, R );    N(-H,-H,-H ),V(-R,-R,0 ),V(-R, 0,-R ),V( 0,-R,-R );  glEnd();  glBegin( GL_QUADS );    N( 1, 0, 0 ),V( R, R, 0 ),V( R, 0, R ),V( R,-R, 0 ),V( R, 0,-R );    N(-1, 0, 0 ),V(-R, R, 0 ),V(-R, 0,-R ),V(-R,-R, 0 ),V(-R, 0, R );    N( 0, 1, 0 ),V( R, R, 0 ),V( 0, R,-R ),V(-R, R, 0 ),V( 0, R, R );    N( 0,-1, 0 ),V( R,-R, 0 ),V( 0,-R, R ),V(-R,-R, 0 ),V( 0,-R,-R );    N( 0, 0, 1 ),V( R, 0, R ),V( 0, R, R ),V(-R, 0, R ),V( 0,-R, R );    N( 0, 0,-1 ),V( R, 0,-R ),V( 0,-R,-R ),V(-R, 0,-R ),V( 0, R,-R );  glEnd();}void drawWireCuboctahedron(){ glBegin(GL_LINE_LOOP),N( 1,0,0),V(R, R,0),V( R,0, R),V( R,-R,0),V( R,0,-R),glEnd();  glBegin(GL_LINE_LOOP),N(-1,0,0),V(-R,R,0),V(-R,0,-R),V(-R,-R,0),V(-R,0, R),glEnd();  glBegin(GL_LINE_LOOP),N( 0,1,0),V(R, R,0),V( 0,R,-R),V(-R, R,0),V(0, R, R),glEnd();  glBegin(GL_LINE_LOOP),N(0,-1,0),V(R,-R,0),V( 0,-R,R),V(-R,-R,0),V(0,-R,-R),glEnd();  glBegin(GL_LINE_LOOP),N( 0,0,1),V(R, 0,R),V( 0, R,R),V(-R,0, R),V(0,-R, R),glEnd();  glBegin(GL_LINE_LOOP),N(0,0,-1),V(R,0,-R),V(0,-R,-R),V(-R,0,-R),V(0, R,-R),glEnd();}void glutWireTorus( float dInnerRadius,float dOuterRadius, int nSides,int nRings ){ short i,j,offset;  float iradius = dInnerRadius,spsi,cpsi,sphi,cphi,        oradius = dOuterRadius, psi, phi,dpsi,dphi;  if( nSides<1 )nSides=1;  if( nRings<1 )nRings=1;  float vertex[3*nSides*nRings], // Allocate the vertices array
        normal[3*nSides*nRings];
  dpsi= 2.0*M_PI/(float)nRings;  dphi=-2.0*M_PI/(float)nSides;  for( psi=0.0,j=0; j<nRings; j++,psi+=dpsi )  { cpsi=cos( psi );    spsi=sin( psi );    for( phi=0.0,i=0; i<nSides; i++,phi+=dphi )    { offset=3*(j*nSides+i);      cphi=cos( phi );      sphi=sin( phi );      *(vertex+offset  )=cpsi*(oradius+cphi*iradius);      *(vertex+offset+1)=spsi*(oradius+cphi*iradius);      *(vertex+offset+2)=sphi*iradius;      *(normal+offset  )=cpsi*cphi;      *(normal+offset+1)=spsi*cphi;      *(normal+offset+2)=sphi;  } }  for( i=0; i<nSides; i++ )  { glBegin( GL_LINE_LOOP );    for( j=0; j<nRings; j++ )    { M( normal+(offset=3*(j*nSides+i)) ); W( vertex+offset );    } glEnd();  }  for( j=0; j<nRings; j++ )  { glBegin( GL_LINE_LOOP );    for( i=0; i<nSides; i++ )    { M( normal+(offset=3*(j*nSides+i)) ); W( vertex+offset );    } glEnd();  }
}void glutSolidTorus( float dInnerRadius,float dOuterRadius,int nSides,int nRings ){ short i,j,offset;  float iradius=dInnerRadius,phi, psi, dpsi,dphi,        oradius=dOuterRadius,spsi,cpsi,sphi,cphi;  if( nSides<1 )nSides=1; nSides++; // Increment the number of sides and rings  if( nRings<1 )nRings=1; nRings++; // to allow for one more point than surface  float vertex[3*nSides*nRings],    // Allocate the vertices array
        normal[3*nSides*nRings];
  dpsi= 2.0*M_PI/float(nRings-1);  dphi=-2.0*M_PI/float(nSides-1);  for( psi=0.0,j=0; j<nRings; j++,psi+=dpsi )  { cpsi=cos( psi );    spsi=sin( psi );    for( phi=0.0,i=0; i<nSides; i++,phi+=dphi )    { offset=3*(j*nSides+i);      cphi=cos( phi );      sphi=sin( phi );      *(vertex+offset  )=cpsi*(oradius+cphi*iradius);      *(vertex+offset+1)=spsi*(oradius+cphi*iradius);      *(vertex+offset+2)=sphi*iradius;      *(normal+offset  )=cpsi*cphi;      *(normal+offset+1)=spsi*cphi;      *(normal+offset+2)=sphi;  } }  glBegin( GL_QUADS );  for( i=0; i<nSides-1; i++ )  for( j=0; j<nRings-1; j++ )  { M( normal+(offset=3*(j*nSides+i)) ); W( vertex+offset );    M( normal+offset+3 );                W( vertex+offset+3 );    M( normal+offset+3*nSides+3 );       W( vertex+offset+3*nSides+3 );    M( normal+offset+3*nSides );         W( vertex+offset+3*nSides );  } glEnd();}static void Dodecahedron( GLenum mode ){ // Magic Numbers:  It is possible to create a dodecahedron by attaching,,,  //                 two pentagons to each face of a cube.  // Coordinates of points are: (+-x,0, z); (+-1, 1, 1); (0, z, x )  // where x = ( -1 + sqrt( 5 ) )/2 = 0.61803398875,  //       z = ( 1 + sqrt( 5 ) )/2  = 1.61803398875.  // const float L=0.850650808354,M=0.525731112119,D=1.61803398875,X=0.61803398875;  glPushMatrix(); glScalef( 0.5,0.5,0.5 );  glBegin(mode),N(0, M, L),V(0, D, X),V(-1, 1, 1),V(-X,0, D),V( X,0, D),V( 1, 1, 1),glEnd();  glBegin(mode),N(0, M,-L),V(0, D,-X),V( 1, 1,-1),V( X,0,-D),V(-X,0,-D),V(-1, 1,-1),glEnd();  glBegin(mode),N(0,-M, L),V(0,-D, X),V( 1,-1, 1),V( X,0, D),V(-X,0, D),V(-1,-1, 1),glEnd();  glBegin(mode),N(0,-M,-L),V(0,-D,-X),V(-1,-1,-1),V(-X,0,-D),V( X,0,-D),V( 1,-1,-1),glEnd();  glBegin(mode),N( L,0, M),V( X,0, D),V( 1,-1, 1),V( D,-X,0),V( D, X,0),V( 1, 1, 1),glEnd();  glBegin(mode),N(-L,0, M),V(-X,0, D),V(-1, 1, 1),V(-D, X,0),V(-D,-X,0),V(-1,-1, 1),glEnd();  glBegin(mode),N( L,0,-M),V( X,0,-D),V( 1, 1,-1),V( D, X,0),V( D,-X,0),V( 1,-1,-1),glEnd();  glBegin(mode),N(-L,0,-M),V(-X,0,-D),V(-1,-1,-1),V(-D,-X,0),V(-D, X,0),V(-1, 1,-1),glEnd();  glBegin(mode),N( M, L,0),V( D, X,0),V( 1, 1,-1),V(0, D,-X),V(0, D, X),V( 1, 1, 1),glEnd();  glBegin(mode),N( M,-L,0),V( D,-X,0),V( 1,-1, 1),V(0,-D, X),V(0,-D,-X),V( 1,-1,-1),glEnd();  glBegin(mode),N(-M, L,0),V(-D, X,0),V(-1, 1, 1),V(0, D, X),V(0, D,-X),V(-1, 1,-1),glEnd();  glBegin(mode),N(-M,-L,0),V(-D,-X,0),V(-1,-1,-1),V(0,-D,-X),V(0,-D, X),V(-1,-1, 1),glEnd();  glPopMatrix();}void glutWireDodecahedron(){ Dodecahedron( GL_LINE_LOOP ); }void glutSolidDodecahedron(){ Dodecahedron( GL_POLYGON ); }/*! * Magic Numbers: r0 = (    1,           0,       0    ) *                r1 = ( -1/3, 2 sqrt(2)/3,       0    ) *                r2 = ( -1/3,  -sqrt(2)/3,  sqrt(6)/3 ) *                r3 = ( -1/3,  -sqrt(2)/3, -sqrt(6)/3 ) *               |r0| = |r1| = |r2| = |r3| = 1 * Distance between any two points is 2 sqrt(6) / 3 * Normals: The unit normals are simply the negative *       of the coordinates of the point not on the surface. */static float t[4][3]={ {  1.0,              0.0,            0.0 },                       { -1.0/3, 0.942809041582,            0.0 },                       { -1.0/3,-0.471404520791, 0.816496580928 },                       { -1.0/3,-0.471404520791,-0.816496580928 } };static void drawTetrahedron( GLenum mode ){ glBegin( mode );  N( -t[0][0],-t[0][1],-t[0][2] ),W( t[1] ),W( t[3] ),W( t[2] );  N( -t[1][0],-t[1][1],-t[1][2] ),W( t[0] ),W( t[2] ),W( t[3] );  N( -t[2][0],-t[2][1],-t[2][2] ),W( t[0] ),W( t[3] ),W( t[1] );  N( -t[3][0],-t[3][1],-t[3][2] ),W( t[0] ),W( t[1] ),W( t[2] );  glEnd();}static void drawIcosahedron( GLenum mode ){ const float r[12][3] =  { {  1.0,          0.0,            0.0            },    {  0.4472135955, 0.894427191000, 0.0            },    {  0.4472135955, 0.276393202252, 0.850650808354 },    {  0.4472135955,-0.723606797748, 0.525731112119 },    {  0.4472135955,-0.723606797748,-0.525731112119 },    {  0.4472135955, 0.276393202252,-0.850650808354 },    { -0.4472135955,-0.894427191000, 0.0            },    { -0.4472135955,-0.276393202252, 0.850650808354 },    { -0.4472135955, 0.723606797748, 0.525731112119 },    { -0.4472135955, 0.723606797748,-0.525731112119 },    { -0.4472135955,-0.276393202252,-0.850650808354 },    { -1.0,          0.0,            0.0            } };  const char v[20][3] =  { { 0,1,2 },{ 0,2,3},{ 0,3,4},{ 0,4,5},{ 0,5, 1},    { 1,8,2 },{ 2,7,3},{ 3,6,4},{4,10,5},{ 5,9, 1},    { 1,9,8 },{ 2,8,7},{ 3,7,6},{4,6,10},{ 5,10,9},    {11,9,10},{11,8,9},{11,7,8},{11,6,7},{11,10,6} };  for( short i=0; i<20; i++ )  { glBegin( mode );    N( (r[v[i][1]][1]-r[v[i][0]][1])*(r[v[i][2]][2]-r[v[i][0]][2])
      -(r[v[i][1]][2]-r[v[i][0]][2])*(r[v[i][2]][1]-r[v[i][0]][1]),       (r[v[i][1]][2]-r[v[i][0]][2])*(r[v[i][2]][0]-r[v[i][0]][0])
      -(r[v[i][1]][0]-r[v[i][0]][0])*(r[v[i][2]][2]-r[v[i][0]][2]),       (r[v[i][1]][0]-r[v[i][0]][0])*(r[v[i][2]][1]-r[v[i][0]][1])
      -(r[v[i][1]][1]-r[v[i][0]][1])*(r[v[i][2]][0]-r[v[i][0]][0]) );    W( r[v[i][0]] ),W( r[v[i][1]] ),W( r[v[i][2]] ); glEnd();} }static void drawRhombicDodecahedron( GLenum mode ){ const float F=R/2;
  const float _n[12][3] =
  { { F,F,0.5},{-F,F,0.5},{-F,-F,0.5},{F,-F,0.5},{ 0,1,0},{-1,0,0},
    { 0,-1,0},{1,0,0},{F,F,-0.5},{-F,F,-0.5},{-F,-F,-0.5},{F,-F,-0.5} };
  const float _r[14][3] =  { {0,0,1},{R,0,0.5},{0,R,0.5},{-R,0,0.5},{0,-R,0.5},{R,R,0},{-R,R,0},
    {-R,-R,0},{R,-R,0},{R,0,-0.5},{0,R,-0.5},{-R,0,-0.5},{0,-R,-0.5},{0,0,-1}};  const char _v[12][4] =  { { 0, 1, 5, 2 },{ 0, 2, 6, 3 },{ 0, 3, 7, 4 },{ 0, 4, 8, 1 },    { 5,10, 6, 2 },{ 6,11, 7, 3 },{ 7,12, 8, 4 },{ 8, 9, 5, 1 },    { 5, 9,13,10 },{ 6,10,13,11 },{ 7,11,13,12 },{ 8,12,13, 9 } };  for( short i=0; i<12; i++ )  { glBegin( mode ); M( _n[i] ); for( short j=0; j<4; j++ )W( _r[_v[i][j]] );    glEnd();} }static void drawSierpinskiSponge( GLenum mode, short num_levels, const float *offset, float scale ){ const short NUM_TETR_FACES=4,ti[4][3]={ {1,3,2},{0,2,3},{0,3,1},{0,1,2} } ;  if( !num_levels )                                           // Vertex indices  for( short i=0; i<NUM_TETR_FACES; i++ )  { glBegin( mode );        N( -t[i][0],-t[i][1],-t[i][2] );    for( short j=0; j<3; j++ )V( offset[0]+scale*t[ti[i][j]][0],                               offset[1]+scale*t[ti[i][j]][1],                               offset[2]+scale*t[ti[i][j]][2] ); glEnd();  } else if( num_levels>0 )  { float local[3]; // Use a local variable to avoid buildup of roundoff errors    num_levels--;    scale/=2;    for( short i=0; i<NUM_TETR_FACES; i++ )    { for( short j=0; j<3; j++ )local[j] = offset[j]+scale*t[i][j];      drawSierpinskiSponge( mode,num_levels,local,scale );  } }}void glutSolidTetrahedron(){ drawTetrahedron( GL_TRIANGLES ); }void glutWireTetrahedron() { drawTetrahedron( GL_LINE_LOOP ); }void glutSolidIcosahedron(){ drawIcosahedron( GL_TRIANGLES ); }void glutWireIcosahedron() { drawIcosahedron( GL_LINE_LOOP ); }void glutSolidRhombicDodecahedron(){ drawRhombicDodecahedron( GL_QUADS ); }void glutWireRhombicDodecahedron(){ drawRhombicDodecahedron( GL_LINE_LOOP ); }void glutSolidSierpinskiSponge( int num_levels, float offset[3], float scale )        { drawSierpinskiSponge( GL_TRIANGLES,num_levels,offset,scale ); }void  glutWireSierpinskiSponge( int num_levels, float offset[3], float scale )        { drawSierpinskiSponge( GL_LINE_LOOP,num_levels,offset,scale ); }///                                весь этот блок может быть построен на GLU.h
/* Compute lookup table of cos and sin values forming around the cirle * Notes: It is the responsibility of the caller to free these tables *        The size of the table is (n+1) to form a connected loop *        The last entry is exactly the same as the first *        The sign of n can be flipped to get the reverse loop */static void CircleTable( float **sint, float **cost, const short n ){ short i,size=abs( n );  float angle=2.0*M_PI/float( !n?1:n );    (*cost=(*sint=(float*)calloc( sizeof(float),size*2+2 ))+size+1)[0]=1.0;
    for( i=1; i<size; i++ )(*sint)[i]=sin( angle*i ),
                           (*cost)[i]=cos( angle*i );    (*cost)[size]=1.0;}void glutSolidSphere( float radius, int slices, int stacks ){ short i,j;  float z0,z1,r0,r1,            /* Adjust z and radius as stacks are drawn. */       *sint1,*cost1,           /* Pre-computed circle */       *sint2,*cost2;    CircleTable( &sint1,&cost1,-slices );    CircleTable( &sint2,&cost2,stacks*2 );    z0=1.0; z1=cost2[(stacks>0)?1:0];           // The top stack is covered    r0=0.0; r1=sint2[(stacks>0)?1:0];           // with a triangle fan    glBegin( GL_TRIANGLE_FAN ); N( 0,0,1 ); V( 0,0,radius );    for( j=slices; j>=0; j-- )    { N( cost1[j]*r1,       sint1[j]*r1,       z1        );      V( cost1[j]*r1*radius,sint1[j]*r1*radius,z1*radius );    } glEnd();    // Cover each stack with a quad strip, except the top and bottom stacks    for( i=1; i<stacks-1; i++ )    { z0 = z1; z1 = cost2[i+1];      r0 = r1; r1 = sint2[i+1];      glBegin( GL_QUAD_STRIP );      for( j=0; j<=slices; j++ )      { N( cost1[j]*r1,       sint1[j]*r1,       z1        );        V( cost1[j]*r1*radius,sint1[j]*r1*radius,z1*radius );        N( cost1[j]*r0,       sint1[j]*r0,       z0        );        V( cost1[j]*r0*radius,sint1[j]*r0*radius,z0*radius );      } glEnd();    }    z0 = z1;                // The bottom stack is covered with a triangle fan    r0 = r1;    glBegin( GL_TRIANGLE_FAN ); N( 0,0,-1 ); V( 0,0,-radius );    for( j=0; j<=slices; j++ )    { N( cost1[j]*r0,       sint1[j]*r0,       z0        );      V( cost1[j]*r0*radius,sint1[j]*r0*radius,z0*radius );    } glEnd();    free( sint1 ); free( sint2 );                // Release sin and cos tables}void glutWireSphere( float radius, int slices, int stacks ){ short i,j;  float r,x,y,z,        // Adjust z and radius as stacks and slices are drawn.       *sint1,*cost1,   // Pre-computed circle       *sint2,*cost2;    CircleTable( &sint1,&cost1,-slices   );    CircleTable( &sint2,&cost2, stacks*2 );    for( i=1; i<stacks; i++ )               // Draw a line loop for each stack    { z = cost2[i];      r = sint2[i];      glBegin( GL_LINE_LOOP );      for(j=0; j<=slices; j++)      { N( x=cost1[j],y=sint1[j],z ); V( x*r*radius,y*r*radius,z*radius );      } glEnd();    }    for( i=0; i<slices; i++ )               // Draw a line loop for each slice    { glBegin( GL_LINE_STRIP );      for( j=0; j<=stacks; j++ )      { N( x=cost1[i]*sint2[j],y=sint1[i]*sint2[j],z=cost2[j] );
        V( x*radius,y*radius,z*radius );      } glEnd();    }    free( sint1 ); free( sint2 );            // Release sin and cos tables}static void Octahedron( GLenum mode ){ glBegin(mode); N( H, H, H),V( 1,0,0 ),V( 0, 1, 0 ),V( 0, 0, 1 );                 N( H, H,-H),V( 1,0,0 ),V( 0, 0,-1 ),V( 0, 1, 0 );                 N( H,-H, H),V( 1,0,0 ),V( 0, 0, 1 ),V( 0,-1, 0 );                 N( H,-H,-H),V( 1,0,0 ),V( 0,-1, 0 ),V( 0, 0,-1 );                 N(-H, H, H),V(-1,0,0 ),V( 0, 0, 1 ),V( 0, 1, 0 );                 N(-H, H,-H),V(-1,0,0 ),V( 0, 1, 0 ),V( 0, 0,-1 );                 N(-H,-H, H),V(-1,0,0 ),V( 0,-1, 0 ),V( 0, 0, 1 );                 N(-H,-H,-H),V(-1,0,0 ),V( 0, 0,-1 ),V( 0,-1, 0 ); glEnd();}void glutWireOctahedron(){ Octahedron( GL_LINE_LOOP ); }void glutSolidOctahedron(){ Octahedron( GL_TRIANGLES ); }void glutSolidCylinder( float radius, float height, int slices, int stacks ){ float *sint,*cost,               // Step in z and radius as stacks are drawn.   zStep=height/( stacks>0?float(stacks):1.0 );   CircleTable( &sint,&cost,-slices );                  // Pre-computed circle   glBegin( GL_TRIANGLE_FAN ); N( 0,0,-1 ); V( 0,0,0 ); // Cover base and top     for( short j=0; j<=slices; j++ )V( cost[j]*radius, sint[j]*radius,0.0 );   glEnd();   glBegin( GL_TRIANGLE_FAN ); N( 0,0,1 ); V( 0,0,height );     for( short j=slices; j>=0; j-- )V( cost[j]*radius,sint[j]*radius,height );   glEnd(); float z0=0.0,z1=zStep;                                       // Do the stacks   for( short i=1; i<=stacks; i++ )   { if( i==stacks )z1 = height;      glBegin( GL_QUAD_STRIP );     for( short j=0; j<=slices; j++ )     { float ct=cost[j],st=sint[j];   N( ct,st,0.0 );       V( ct*=radius,st*=radius,z0 ); V( ct,st,z1 );     } z0=z1; z1+=zStep;              glEnd();   }   free( sint );                                 // Release sin and cos tables}void glutWireCylinder( float radius, float height, int slices, int stacks ){ float z=0.0,*sint,*cost,                             // Step in z and radius   zStep=height/( stacks>0?float(stacks):1.0 );        // as stacks are drawn.   CircleTable(&sint,&cost,-slices);                   // Pre-computed circle   for( short i=0; i<=stacks; i++ )                      // Draw the stacks...   { if (i==stacks)z=height; glBegin( GL_LINE_LOOP );     for( short j=0; j<slices; j++ )     { N( cost[j],       sint[j],     0.0 );       V( cost[j]*radius,sint[j]*radius,z );     } glEnd(); z+=zStep;   }   glBegin( GL_LINES );                                // Draw the slices   for( short j=0; j<slices; j++ )   { N( cost[j],       sint[j],       0.0    );     V( cost[j]*radius,sint[j]*radius,0.0    );     V( cost[j]*radius,sint[j]*radius,height );   } glEnd();   free( sint );                               // Release sin and cos tables}// Draws a solid cone//void glutSolidCone( float base, float height, int slices, int stacks ){ short i,j;  float z0,z1,r0,r1,               // Step in z and radius as stacks are drawn.        *sint,*cost;                                    // Pre-computed circle  const float zStep=height/( ( stacks>0 )? stacks:1 ),  // Scaling factors              rStep=base / ( ( stacks>0 )? stacks:1 ),  // for vertex normals              cosn =( height / hypot( height,base ) ),              sinn =( base   / hypot( height,base ) );    CircleTable( &sint,&cost,-slices );    z0 = 0.0;  z1 = zStep;    // Cover the circular base with a triangle fan...    r0 = base; r1 = r0-rStep;    glBegin( GL_TRIANGLE_FAN ); N( 0.0,0.0,-1.0 ),V( 0.0,0.0, z0 );      for( j=0; j<=slices; j++ )V( cost[j]*r0, sint[j]*r0, z0 );    glEnd();    for( i=0; i<stacks-1; i++ )         // Cover each stack with a quad strip,    { glBegin( GL_QUAD_STRIP );         //      except the top stack      for( j=0; j<=slices; j++ )      { N( cost[j]*cosn,sint[j]*cosn,sinn );        V( cost[j]*r0,sint[j]*r0,z0   );        V( cost[j]*r1,sint[j]*r1,z1   );      } z0=z1; z1+=zStep;
        r0=r1; r1-=rStep; glEnd();    }    glBegin( GL_TRIANGLES );                  // The top stack is covered    N( cost[0]*sinn, sint[0]*sinn, cosn );    //  with individual triangles    for( j=0; j<slices; j++ )    { V( cost[j+0]*r0,sint[j+0]*r0,z0 ),V( 0,0,height );      N( cost[j+1]*sinn,sint[j+1]*sinn,cosn );      V( cost[j+1]*r0,  sint[j+1]*r0,  z0   );    } glEnd();    free( sint );                             // Release sin and cos tables}void glutWireCone( float base,float height, int slices,int stacks){ short i,j;  float z=0.0,r=base,*sint,*cost;  // Step in z and radius as stacks are drawn.  const float zStep=height/( (stacks>0)?stacks:1 ),              rStep=base  /( (stacks>0)?stacks:1 ),              cosn=( height/hypot( height,base ) ),  // Scaling factors              sinn=( base  /hypot( height,base ) );  // for vertex normals    CircleTable( &sint,&cost,-slices );              // Pre-computed circle    for( i=0; i<stacks; i++ )                        // Draw the stacks...    { glBegin( GL_LINE_LOOP );      for( j=0; j<slices; j++ )      { N( cost[j]*sinn,sint[j]*sinn,cosn ),V( cost[j]*r,sint[j]*r,z );      } glEnd(); z+=zStep; r-=rStep;    }    r = base;    glBegin( GL_LINES );    for( j=0; j<slices; j++ )                        // Draw the slices    { N( cost[j]*sinn,sint[j]*sinn,cosn );      V( cost[j]*r,sint[j]*r,0.0  ),V( 0.0,0.0,height );    } glEnd();    free( sint );                                // Release sin and cos tables}/*#include <GL/GLu.h>//! ===========================================================================void glutSolidSphere( float radius, int slices, int stacks ){ GLUquadricObj *S=gluNewQuadric();//    gluQuadricDrawStyle( S,GLU_FILL );      gluSphere( S,radius, slices, stacks );      gluDeleteQuadric( S );}void glutWireSphere( float radius, int slices, int stacks ){ GLUquadricObj *S=gluNewQuadric();      gluQuadricDrawStyle( S,GLU_LINE );      gluSphere( S,radius, slices, stacks );      gluDeleteQuadric( S );}void glutSolidOctahedron(){ glutSolidSphere( M_SQRT1_2,4,2 ); }void glutWireOctahedron(){ glutWireSphere( M_SQRT1_2,4,2 ); }void glutSolidCylinder( float radius, float height, int slices, int stacks ){ GLUquadricObj *S=gluNewQuadric();//    gluQuadricDrawStyle( S,GLU_FILL );//    gluQuadricNormals( S,GLU_FLAT );//    gluQuadricOrientation( S,GLU_OUTSIDE );      gluCylinder( S, radius,radius, height, slices, stacks );      gluDeleteQuadric( S );}void glutWireCylinder( float radius, float height, int slices, int stacks ){ GLUquadricObj *S=gluNewQuadric();      gluQuadricDrawStyle( S,GLU_LINE );      gluCylinder( S, radius,radius, height, slices, stacks );      gluDeleteQuadric( S );}void glutSolidCone( float radius, float height, int slices, int stacks ){ GLUquadricObj *S=gluNewQuadric();//    gluQuadricDrawStyle( S,GLU_FILL );      gluCylinder( S, radius,0, height, slices, stacks );      gluDeleteQuadric( S );}void glutWireCone( float radius, float height, int slices, int stacks ){ GLUquadricObj *S=gluNewQuadric();      gluQuadricDrawStyle( S,GLU_LINE );      gluCylinder( S, radius,0, height, slices, stacks );      gluDeleteQuadric( S );}//! не получилосьvoid glutSolidTorus( float dInnerRadius,float dOuterRadius,int nSides,int nRings ){ GLUquadricObj *S=gluNewQuadric();//    gluQuadricDrawStyle( S,GLU_FILL );      gluDisk( S, dInnerRadius, dOuterRadius, nSides, nRings );      gluDeleteQuadric( S );}void glutWireTorus( float dInnerRadius, float dOuterRadius, int nSides, int nRings ){ GLUquadricObj *S=gluNewQuadric();      gluQuadricDrawStyle( S,GLU_LINE );      gluDisk( S, dInnerRadius, dOuterRadius, nSides, nRings );      gluDeleteQuadric( S );}*/