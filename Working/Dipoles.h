/**
 **     Моделирование кинематики, динамики и механики взаимодействия
 **     множества поляризованных частиц первого и второго порядка
 **     (пространственные вихреисточники и диполи)
 **                                                   (c)2021 ‏יְרוּשָׁלַיִם
 **/
#include "../Math/Tensor.h"
#include "../Window/ConIO.h" // -Wno-narrowing для AMD~64 и ConIO для отладки

const int                  /// блок исходных констант - параметров эксперимента
      Dipole_route=4096,   // длина истории в отсчётах визуализуемого маршрута
      Quantum_exp=150,     // квант времени непрерывного процесса вычислений
      Quantum_wait=50,     // квант на прерывание для ожидания внешних операций
      Quantum_video=500;   // интервал времени ожидания нового видео-кадра [мс]
const Real TimeStep=1e-3,  // интервал времени для одного такта эксперимента
               eps=1e-12;  // условная потеря величины или длины вектора ≈ 0
                           /// блок общих - управляемых настроек эксперимента
                           //              пространственных расчетов
extern struct status /// Маска настройки режимов вычислительного эксперимента
{ unsigned Grid: 2,  // признак разметки континуальной пространственной сетки
                     //   0-пусто; 1-оси; 2-рёбра; 3-вместе
          Field: 2,  // векторное поле скоростей в точках сетки
                     //   0-чисто; 1-вызван; 2-полное; 3-вместе
          Model: 2,  // признак раскраски или контуров диполя
                     //   0-только трек; 1-точка; 2-ребра; 3-цвет
           Edge: 2,  // режимы притяжения корпускул: true-ядро; false-шарик
                     //   0-нет; 1-гладкая функция; 2-упругий шарик; 3-вместе/2
           Body: 1,  // 1-движение частиц с массой+инерцией; 0-чисто кинематика
           Flow: 1;  // Внешний поток 1-поддерживается; 0-свободно изменяется
                     // ≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈≈
  status():          // одна частичка не сильно грузит вычислительные процессы
    Grid( 1 ),Field( 3 ),Model( 3 ),Edge( 1 ),Body( true ),Flow( false ){}
} ex;
struct Dipole
{ Vector R,    // мгновенные координаты для центральной точки активного диполя
         V,    // скорость встречного потока в глобальной системе отсчета
         M,    // дипольный момент или активная векторная/тензорная масса (=1)
         W;    // действующая локальная скорость в инерциальной системе отсчета
};
class Dipoles         // пространство континуально-корпускулярного эксперимента
{ Dipole *D;          // рой независимых диполей внутри расчётного пространства
public:               // бесконтрольный доступа к свободным частицам ограничен
 Real T;              // физическое время на момент формирования массива частиц
 Dipole Mean;         // усреднённые величины всего массива активных корпускул
 Dipole& operator[]( int );  // доступ к диполю со сбросом программы при ошибке
 Dipoles& Average(_Real T ); // расчет всех осредненных значений для роя частиц
 Dipoles& Install( int n );  // выделение и расчистка памяти всего слоя частиц
 Dipoles& Initial();         // начальные условия в первом рое корпускул
};
extern Dipoles *Dipoles_array;  // массив или рой-группа диполей в пространстве
extern unsigned nDip,           // количество корпускул в активном эксперименте
                Time_count;     // отсчёт исполняемого такта вычислений
void ReInstall_TimeSpace( int N ); // очистка и переустановка всего роя диполей
//
//!  Главная процедура реализации одного такта вычислительного эксперимента.
//   В процедуре не предполагается возможностей для внешних прерываний.
//
bool One_Time_Step();    // один шаг реальных вычислений без внешних прерываний
bool VideoStage();       // контроль вычислительной среды к продолжению работы

struct Model: Base
{ Model(): Base(){};
  Model& operator =( _Real Scale ){ Base::operator=(Scale); return *this; }
  Model& operator =( _Point Rc   ){ Point::operator=(Rc);   return *this; }
  Model& operator+=( _Vector dR  ){ Point::operator+=(dR);  return *this; }
  Model& dipole( _Real acl=0.0, bool=false );                 // {-1<s<+oo}
};
void Text_to_ConIO( Dipoles &D ); // "отладочная" печать
//
//!    функции скалярного и векторного воздействия одиночного диполя
///
//inline Real one_2( _Real r ){ return r<1 ? sqrt(r)*(3.5-2.5*r) : 1/(r*r); }
//inline Real one_3( _Real r ){ return r<1 ? sqrt(r)*(4.5-3.5*r) : 1/(r*r*r); }
inline Real one_2( _Real r ){ return r<1 ? 2-r*r : 1/(r*r); }     // 2^2
inline Real one_3( _Real r ){ return r<1 ? 2-r*r*r : 1/(r*r*r); } // 3^3
inline Vector dipole_v // вызванные скорости
    ( _Vector d, // дипольный радиус до первого критического узла встреч потока
      _Vector r ) // радиус-вектор удаленной точки к контрольному центру диполя
    { Real s=norm(r); return (r*(d%r)-r*(d*r)/2)*one_3( sqrt( s/norm(d) ) )/s;
    }
//inline Vector dipole_flow( _Vector d, _Vector r ){ return dipole_v( d,r )+d; }
//{ Real s=norm( r ),f=one_3( sqrt( s/norm( d ) ) );  // полный вектор скорости
//  return ( r*(1-f)*(d%r) + r*( 1+0.5*f )*(d*r) )/s; // со встречным потоком
//}
//extern unsigned long RealTime; // компьютерное время вычислительного процесса
