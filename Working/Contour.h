//
//  Contour.h                                                 /2020.10.19/
//  Программы построения простых одномерных функций
//  2020-09-29 - к доработкам:
//   1 +? трёхмерные кривые со скалярным аргументом в качестве дистанции между
//        смежными точками Contour?? (K-Frame.c++ - в целом неплохо получается)
//   2 -- триангулированные поверхности между шпангоутами с точками дополнений
//     -- со сглаживанием нормалей и их точек опоры по смежным шпациям
//
#ifndef __Contour__
#define __Contour__
#include "..\Math\Vector.h"

enum metaLine { easy,first,spline }; // ломаная; - Эрмит 2-го порядка; - Сплайн

class Contour
{ Point *P,*C;            // адреса массивов и производных в узлах интерполяции
  Real *A;                // скалярный аргумент - дистанция по точкам от начала
  metaLine met;           // easy-ломаная; first-эрмит по узлам; spline-сплайн
  bool ext;               // признак включения внешней последовательности точек
public:
  size_t len;             // Индексная длина линейного массива чисел
  Contour( size_t l=0 );      // создание нового контура c индексным аргументом
  Contour( Point*,size_t=0 ); // c вовлечением внешней последовательности точек
 ~Contour();
  Point& operator[]( int k );  // In\Out - полный доступ к точке по её индексу
  Point operator()( _Real );   // результат интерполяции по индексу или длине
//Real  operator()( int k );   // аргумент - индекс }0÷N-1{ или длина }0÷(N-1){
  Point forX( _Real X );       // выбор первого вхождения точки с координатой Х
  //
  //    Активизация различных режимов интерполяции
  //
  Contour& Mode                     // переопределение всех характеристик линии
         ( metaLine=easy,           // тип кривой: ломаная, эрмитова или сплайн
           bool arg=false,          // аргумент по индексам к единице или длина
          _Real=1e6,_Real=1e6       // концевые сопряжения для Эрмита и сплайна
         );                         // наклон или 1е6-точка перегиба
  //    конкретные установки режимов интерполяции определяются в процедуре Mode
private:
  Contour& Easy(){ met=easy; return *this; } // установка линейной интерполяции
  Contour& First();     // Эрмит c осреднёнными производными в узлах сопряжения
  Contour& SpLine( _Real a1=1e6,     // активизация простой сплайн-интерполяции
                   _Real aN=1e6 );   // производная в начале и в конце отрезка
};                                   // если≥1e6 - на концах ≡0 точка перегиба

//Point Point::operator /= ( Real e ){ X/=e; Y/=e; Z/=e; return *this; }
inline Point operator * ( Point c,Real e ){ c.X*=e; c.Y*=e; c.Z*=e; return c; }
inline Point operator / ( Point c,Real e ){ c.X/=e; c.Y/=e; c.Z/=e; return c; }

#endif
