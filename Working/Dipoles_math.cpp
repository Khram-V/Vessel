/**
 **     Моделирование кинематики, динамики и механики взаимодействия
 **     множества поляризованных частиц первого и второго порядка
 **     (пространственные вихреисточники и диполи)
 **                                                             (c)2021 ‏יְרוּשָׁלַיִם
 **/
#include "Dipoles.h"                  // базовые структуры тензорной математики

const Real Vol=EqSphere*_Pi*4/3,      // объем частицы-шарика = 1,0        [м³]
//         g=9.8106,                  // ускорение свободного падения    [м/с²]
           ro=1.29,                   // плотность воздуха              [кг/м³]
           R_Earth=6367554.0;         // радиус Земли, сфероид Красовского  [м]
//
//! Главная процедура реализации одного такта вычислительного эксперимента.
//  В процедуре не предполагается возможностей для внешних прерываний.
//
bool One_Time_Step()
{
 Dipoles &Prev=Dipoles_array[Time_count%Dipole_route],
         &Next=Dipoles_array[(Time_count+1)%Dipole_route];
 unsigned &Q=nDip;
  for( int i=0; i<Q; i++ )           // здесь копируется весь предыдущий массив
                Next[i]=Prev[i];     // ... возможно за зря
//
//  1) - деформация потока в локальном местоположении (в центре) корпускулы,
//  суммированием вызванных скоростей от всех окружающих поляризованных частиц.
//  Отсутствие влияния окружающей среды предполагает, что несмотря на быстрые
//  перемещения диполей в пространстве, их внешнее влияние - вызванные скорости
//  вычисляются исходя из статического местоположения в конкретных
//  пространственных координатах на данный момент времени (то есть, с удалением
//      влияние безусловно ослабевает, или как бы - «теория относительности»,
//      и опять же при условии, что взаимное действие мгновенно-быстрое).
//
  if( Q<2 )Next[0].V=-1.0; else
  {
#pragma omp parallel for
    for( int i=0; i<Q; i++ )           // расслоение к параллельным вычислениям
    { Dipole &B=Next[i]; B.V=0.0;      // вычисляются все наведённые скорости в
      for( int k=0; k<Q; k++ )if(k!=i) // центре текущего местоположения диполя
      { const Dipole &D=Prev[k];       // вызванные скорости связаны с объемом
        B.V += dipole_v( D.M,B.R-D.R );// частицы - кубика, *EqSphere - изнутри
      } const Real U=norm( B.V );      // ≈≈≈≈≈≈≈≈≈ терять длину здесь не стоит
      if( U<eps ){ if( !U )B.V=eps; else B.V*=eps/sqrt( U ); }
    }
  }
//  1.1) - корректировка вызванных скоростей для придания совместного
//         поступательного движения для всех частиц сразу
//
  if( ex.Flow )          // наложение свободного набегающего потока на скорости
  for( int i=0; i<Q; i++ )Next[i].V+=(Vector){-1.0,0};   // саморазгона диполей
//
//  2)+ исходный поверочный вариант простого скалярного притяжения корпускул.
//      Постоянная притяжения (/_Pd/60) пока выбирается достаточно малой,
//      чтобы расталкивание шариков не проявлялось взрывным разлётом
//
  if( ex.Edge )                      // goto A3; пусть пока закрыто - совсем...
  {
#pragma omp parallel for // reduction(+ V)
    for( int i=0; i<Q; i++ )
    { Vector V; V=0.0;
      const Dipole &B=Prev[i]; // здесь есть наведенные скорости от всех частиц
      for( int k=0; k<Q; k++ )if( i!=k )
      { const Dipole &D=Prev[k];
        Vector r; r=( B.R-D.R )*EqSphere;   // радиус-вектор между корпускулами
        Real ss=norm( r ),s=sqrt( ss );     // радиус соприкосновения частиц
        r *= 1/s;                           // нормированный вектор поверхности
        if( ex.Edge&1 )V += r*(1/ss-1)/ss;  //! функция притяжения/отталкивания
        if( ex.Edge&2 )                     //! вариант соприкосновения шариков
        { if( s>1.4655712319 )V -= r/ss;    // при квадратичном притяжении
                        else  V += r*(1-s); // и линейно-упругое столкновение
      } }
      if( ex.Edge==3 )V/=2.0;               // сумма средне-гладкошариковых сил
      Next[i].V += V*TimeStep/(_Pd*60);     // Приращение скорости под
    }                                       // действием взаимных сил
  }
  // 3.1 В динамическом варианте дипольный момент будет включать величину
  //     рассогласования скорости частицы относительно встречного потока.
  //
  //  В кинематическом варианте дипольный момент будет нормирован (одинаков),
  //    тогда обретённая скорость частицы просто компенсирует разницу М=1,5∙Ω∙V
  //    Формально кинематика исполняется в единой-абсолютной системе координат
  //
  if( ex.Body )
  {
#pragma omp parallel for
    for( int i=0; i<Q; i++ )
    { Dipole &D=Next[i],            // дипольный момент на новый отсчет времени
             &B=Prev[i];            //    опорная поляризованная диполь-частица
      Vector VM; VM=D.M+(D.V+B.V)/2;// средний ветер на старый парус или
//     D.W += VM * TimeStep;        // ускорение от рассогласования силы и тяги
       D.R += VM * TimeStep;        // траектория движения центра тяжести
       D.M = -dir( D.V+B.V );       // подворот диполя встреч новому потоку
//    Vector A=-(D.V-B.V)/TimeStep; // приращение внешней скорости - ускорение
//     D.M = -dir( D.V );           // подворот диполя встреч потоку *EqSphere
//     A += (D.M+D.V)/TimeStep;     // ускорение от рассогласования силы и тяги
//     D.W = A*TimeStep;            // ускорение с учетом присоединённой массы
//     D.R += D.W * TimeStep;
  } } else
  {
  // 3.2 В кинематическом варианте дипольный момент будет нормирован (одинаков)
  //    тогда обретённая скорость частицы просто компенсирует разницу М=1,5∙Ω∙V
  //    Формально кинематика исполняется в единой-абсолютной системе координат
  //
#pragma omp parallel for
    for( int i=0; i<Q; i++ )
    { Dipole &D=Next[i];
      D.M = dir( -D.V );             // подворот диполя встреч потоку *EqSphere
      D.R += (D.M+D.V)*TimeStep;
    }
  }
  // + (Vector){ sin(k*.02),sin(k*.02),sin(k*.01) }     // идём-едем, загуляли
  //           * sin(k*.04)*.005;                      // гармонические шатания
  //
  Next.Average( Time_count*TimeStep );  // слежение за временем эксперимента
  return ( ++Time_count )>0;            // прибавка счетчика в последний момент
                                        //! с запросом приостановки вычислений
}
Dipole& Dipoles::operator[]( int k ) // доступ к диполю, полный сброс на ошибке
{ if( (unsigned)k>=nDip )Break("Неверный индекс к Dipoles[%d]",k); return D[k];
}
// Подведение итогов с попутным расчетом центра масс всей динамической системы
//            и осреднением всех динамических величин
//
Dipoles& Dipoles::Average( _Real Time )
{ int i; T=Time; Mean.R=0.0;     // текущее время и местоположение
  Mean.M=Mean.V=Mean.W=0.0;      // дипольный момент, скорость потока и частицы
  for( i=0; i<nDip; i++ )   // с расчетом центра масс всей динамической системы
     Mean.R+=D[i].R,Mean.V+=D[i].V,Mean.W+=D[i].W,Mean.M+=D[i].M;
  if(i>1)Mean.R/=i,Mean.M/=i,Mean.W/=i,Mean.V/=i; else Mean.V=-1; return *this;
}
// Предустановка и начальная инициализация вычислительного эксперимента в целом
//
Dipoles& Dipoles::Install( int N )     // количество условных нуклонов в группе
{                                              // динамическое добавление точек
  if( nDip<N )D=(Dipole*)Allocate( N*sizeof( Dipole ),D );  // по необходимости
  for( int k=0; k<nDip; k++ ) // без повторений но с предварительной расчисткой
  { D[k].M=(Vector){ 1,0,0 }, // дипольные моменты
    D[k].V=(Vector){ 0,0,0 }, // изначальная скорость набегающего потока
    D[k].W=(Vector){ 0,0,0 }, // скорость частицы в инерциальной(глобальной) СК
    D[k].R=(Vector){ 0,0,0 }; // координаты корпускулы в абсолютных отсчётах
    if( ex.Flow )D[k].V.x=-1; // внешний набегающий поток
  }
}
Dipoles& Dipoles::Initial()
{ switch( int k=nDip )        // в предустановке только начальный рой корпускул
  { case 1: break;                                               //  H водород
    case 2: D[1].R.y=-(D[0].R.y=0.5); break;                     // ²H дейтерий
    case 3: D[0].R=(Vector){0,0.5,.28866},                       // ³H тритий
            D[1].R=(Vector){0,-.5,.28866},D[2].R=(Vector){0,0,-0.57733}; break;
    case 4: D[0].R=(Vector){0.5,0,.35355},D[2].R=(Vector){0,0.5,-.35355}, // Не гелий 2+2 ~~ Be бериллий 4+5
            D[1].R=(Vector){-.5,0,.35355},D[3].R=(Vector){0,-.5,-.35355}; break;
    case 5: D[0].R=(Vector){0,0.5,.28866},D[2].R=(Vector){0,0,-.57733}, // B бор 5+6
            D[1].R=(Vector){0,-.5,.28866},D[4].R.x=-( D[3].R.x=.7071 ); break;
    case 6: D[0].R.x=-(D[1].R.x=.7071),D[2].R.y=-(D[3].R.y=.7071), // C углерод 6+6
            D[4].R.z=-(D[5].R.z=.7071); break;    // √2 по касательной
    case 7: D[6].R.x=-(D[0].R.x=.55)-.12; k--;    // Li Литий 3+4 ~~ N Азот 7+7
          while(--k>0)D[k].R=(Vector){0,sin(k*_Pd/5),cos(k*_Pd/5)}*.759; break;
    case 8: while(k--)D[k].R=(Vector){(k%2)-.5,k/4-.5,(k%4)/2-.5}*0.866; break; // ~~ О кислород 8+8
    case 9: k--; while(k--)D[k].R=(Vector){(k%2)-.5,k/4-.5,(k%4)/2-.5};  break; // Ве Берилий 4+5 ~~ F фтор 9+10
    case 10: D[8].R.x=-(D[9].R.x=1.32); k-=2;               // ~~ Ne неон 10+10
              while(k--)D[k].R=(Vector){(k%2)-.5,k/4-.5,(k%4)/2-.5}*1.24; break;
    case 27:  while(k--)D[k].R=(Vector){(k%3)-1,k/9-1,(k%9)/3-1}*0.7071;  break; // Al алюминий 13+14 ~~ Co кобальт 27+32
    case 64:  while(k--)D[k].R=(Vector){(k%4)-1.5,k/16-1.5,(k%16)/4-1.5}; break; //*0.71
    case 125: while(k--)D[k].R=(Vector){(k%5)-2,  k/25-2,  (k%25)/5-2  }; break; //*0.528;
    case 216: while(k--)D[k].R=(Vector){(k%6)-2.5,k/36-2.5,(k%36)/6-2.5}; break;
    case 343: while(k--)D[k].R=(Vector){(k%7)-3,  k/49-3,  (k%49)/7-3  }; break;
    case 512: while(k--)D[k].R=(Vector){(k%8)-3.5,k/64-3.5,(k%64)/8-3.5}; break;
    case 729: while(k--)D[k].R=(Vector){(k%9)-4,  k/81-4,  (k%81)/9-4  }; break; //*0.35;
    default: Break( "Неверное количество[%d] ≠ 1,2,3,4,5,6,7,8,9,"
                                        "27,64,125,216,343,512,729",nDip );
  } return Average( 0.0 );
}
