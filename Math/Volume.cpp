/**
      Трехмерные тензорные вычислительные объекты и нестационарные
      континуально-корпускулярные операции в адаптируемых и рекурсивно
      сгущаемых массивах нерегуляризованных узлов для сопряженных ячеек
      в интерполяционном окружении неразрывных пространств физических
      параметров состояния и механики глобального взаимовлияния с локальным
      взаимодействием поляризованных частиц-ячеек сплошной среды
      с естественными реологическими свойствами.
                                          (с)05-2016, В.Храмушин, ... Иерусалим
 **/
//    В геометрических построениях и физических операциях тензоры
//        служат для фиксации физических полей в локальных базисах,
//    и - для взаимного преобразования координат векторных отсчетов
//                           и пространственных физических объектов
#include "Volume.h"
//
//    Исходное пространство верхнего рекурсивного уровня создается одномоментно
//     -- нагромождение временных слоев выполняется в ссылках внутри узлов Node
//                                                  x(вправо),y(вверх),z(ближе)
Space::Space( int i,int j,int k, Point P, Real S ):
        Base( (Point){P.X*S*i,P.Y*S*j,P.Z*S*k},S ),nX(i),nY(j),nZ(k)
{  Ns = (Node***)malloc( (nZ+1)*sizeof( Node**) );     // полный размер +1 узел
   for( k=0; k<=nZ; k++ )                              // и начальное обнуление
   { Ns[k]=(Node**)malloc( (nY+1)*sizeof( Node*) );    // рекурсивных вставок
     for( j=0; j<=nY; j++ )Ns[k][j]=(Node*)calloc( nX+1,sizeof( Node ) );
   }
   for( k=nZ; k>=0; k-- )
   for( j=nY; j>=0; j-- )
   for( i=nX; i>=0; i-- )                              //! собственно настройка
   { Node &Nw=Ns[k][j][i];                             //! поисковой индексации
//   Nw=out( (Vector){ i,j,k } );       ++++++         // абс. координаты узла
     Nw.x=(i==nX)?0:&(Ns[k][j][i+1]);                  // а по дальним границам
     Nw.y=(j==nY)?0:&(Ns[k][j+1][i]);                  //   разорванные ссылки
     Nw.z=(k==nZ)?0:&(Ns[k+1][j][i]);
}  }
Space::~Space()
{  for( int k=nZ; k>=0; k-- )
   { for( int j=nY; j>=0; j-- )free( Ns[k][j] ); free( Ns[k] ); } free( Ns );
}
//      В начальный момент времени все корпускулы Array ориентированы по
//      по дипольному моменту MV, и по нему же устанавливается начальная
//      скорость движения всего пространства Space - с быстрой динамической
//      перенастройкой видимой сцены относительно центра масс всех корпускул
//
Ball& Ball::Fix( int kt, int lt, int lnew )    // перестройка старой траектории
{ Vector *newR=NULL;                           // к нулевому исходному индексу
  if( !kt )dR=(Vector*)Allocate( lnew*sizeof(Vector),dR ); return *this;
  if( lnew )                                               // создание нового
  { newR=(Vector*)Allocate( lnew*sizeof(Vector) );         // чистого маршрута
    if( dR )for( int i=0; i<lt && i<lnew; i++ )newR[i]=dR[(i+kt)%lt];
  } if( dR )Allocate( 0,dR ); dR=newR; return *this;       // и есть что снести
}
Array& Array::Create
( int  mPoints,           // количество корпускул   -- 1000
  int  Fly_count,         // длина следа траектории -- 1440
  Real mv )               // поляризация нейтрона снимается спиновым гироскопом
{ if( mPoints>0 )         // происходит управление памятью и списками корпускул
  { int m=mc; //,n=nc;    // текущее состояние счетчиков списков
    if( !mc ){ kt=lt=0; mc=1000; Dip=NULL; }     // чистый конструктор
    if( (nc=mPoints)>mc )mc=mPoints+120;           // признак расширения списка
    if( mc>m )                                     // увеличение буфера памяти
      Dip=(Ball*)Allocate( mc*sizeof(Ball),Dip );  // и нули остаются на местах
    for( m=0; m<mc; m++ )Dip[m].Fix( kt,lt,Fly_count );    // правка траекторий
                                        lt=Fly_count;      // длина траектории
  } else Clear(); kt=0; dT=(MV=mv)/240;    // зачистка поляризованных корпускул
  return *this;                            //
}
Array& Array::Clear()
{ if( mc>0 )
  { if( lt>0 )for( int i=0; i<mc; i++ )Allocate( 0,Dip[i].dR );
                                       Allocate( 0,Dip );
  } kt=lt=nc=mc=0; Dip=NULL; return *this;
}
Array& Array::Add( _Point _R,_Vector _M,_Vector _V ) // вброс новой корпускулы
{ if( ++nc>mc )Dip=(Ball*)Allocate( (mc=nc)*sizeof(Ball),Dip );
  { Ball &D=Dip[nc-1]; D.M=_M; D.R=_R; D.V=_V;
      if( lt )D.dR=(Vector*)Allocate( lt*sizeof(Vector),D.dR );
  } return *this;
}
