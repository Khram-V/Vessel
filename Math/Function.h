//
//  Function.h                                                 /2008.11.09/
//  Программы построения простых одномерных функций
//
#ifndef __Function__
#define __Function__
#include "../Type.h"

enum metaLine { easy,first,spline }; // ломаная; - Эрмит 2-го порядка; - Сплайн
//
//         Построение одномерных гладких числовых функций
//         Функция может сопрягаться с внешними массивами
//         Если аргумент не задан, то им считается номер индекса точки
//                        (условно - единичный шаг от 0 до length-1)
class Function
{ Real *_Y,*_X,*_2;       // Адреса массивов и производных в узлах интерполяции
  metaLine met;           // 0-ломаная линия; 1-производная в узлах; 2-сплайн
  size_t m;               // зарезервированная длина рядов в оперативной памяти
  Function& check(int&);  // внутренний контроль-управление оперативной памятью
public:                   // m==0 - признак подключения внешних массивов
  size_t length;          // Индексная длина линейного массива чисел
  Function();             // чистый конструктор без данных
  Function( size_t S );   // создание одного нового массива
  Function( Real *Y, size_t S=0 );       // значения функции на внешнем массиве
  Function( Real *Y, Real *X, size_t S=0 ); //... то же для функции и аргумента
 ~Function();              // + надо быть осторожным и не удалять чужие массивы

  Real& operator[]( int y );  // In/Out доступ к функции по индексному отсчету
  Real& operator()( int x );  // и функциональное обращение к аргументу, память
                           //! для аргумента и функции выделяется по превышению
  //
  //    Активизация различных режимов интерполяции
  //
  Function& Easy(){ met=easy; return *this; }  // Сброс к линейной интерполяции
  Function& First();    // По Эрмиту с осреднением производных в узловых точках
  Function& SpLine( _Real Yx1=1e6,   // Активизация сплайн-интерполяции
                    _Real YxN=1e6 ); // Производная в начале и в конце отрезка
                                     // если≥1e6 - на концах ≡0 точка перегиба
  //    Собственно интерполяция
  //    - оператор вычисляет значение функции в зависимости от контекстной
  //      настройки массивов и режимов использования
  //    - функции value и derivative срабатывают по тем же правилам при pw<0,
  //      иначе принудительно вменяется использование полинома степени pw>=0.
  //
  Real operator()( _Real arg );         // интерполяция pw=1, или указано в met
  Real derivative( _Real arg,int pw=-1 ); // первая производная
  Real value( _Real arg, int pw=-1 );  // полиномиальная интерполяция при pw>=0
  //
  //   Инструментальные дополнения для связи с другими программами
  //
  //              -- his=true - с наложением на предыдущие/внешние экстремумы
  //                   =false - необходима изначальная внутренняя инициализация
  Function& extrem( Real &xMin,Real &yMin, Real &xMax,Real &yMax, bool=false );
};
//  Точка {X,Y} пересечения двух прямых линий L(1,2) и L(3,4) на плоскости
//
inline bool Cross( _Real x1,_Real y1, _Real x2,_Real y2,
                   _Real x3,_Real y3, _Real x4,_Real y4, Real &X,Real &Y )
{ Real Det=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4); if( fabs( Det )<1e-6 )return false;
  X=((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/Det;
  Y=((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/Det; return true;
}
#endif
