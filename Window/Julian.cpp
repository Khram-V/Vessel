////!   Юлианский календарь по Кембриджскому исчислению                 ©«JulDay»//-     + onetime            - текущее время с точностью до одной целой секунды//-     + Event::Now + Check - текущее время и контроль с подстройкой счисления//!   с некоторыми формальностями дискретной разметки и угловыми размерениями//-     + AxisStep + Angle + AtoD + DtoA - шаг шкал и временно/угловые разборки
//-     + find - для поиска ближайшего слева индекса в регулярном (±) массиве//#include <time.h>#include <string.h>#include "../Type.h"long julday( int mm, int id, int iy )        // Numerical Recipes in C{ long jy,jm;                                // Cambridge University PRESS 1988  if( iy<0 )++iy;  if( mm>2 )jy=iy,jm=mm+1;                 // Gregorian calendar was aborted      else  jy=iy-1,jm=mm+13;              //                 on 1582.Oct.15  jm = long( floor( 365.25*jy )+floor( 30.6001*jm )+id+1720995 );  if( id+31*(mm+12*iy)>=(15+31*(10+12*1582)) ){ jy=0.01*jy; jm+=2-jy+jy/4; }  return jm;}void julday( long julian, int& mm, int& id, int& iy ){ long jc,jd,je;  if( julian>=2299161 )  { je=( double( julian-1867216 )-0.25 )/36524.25; julian+=1+je-je/4;  } jc=long( 6680.0+( double( (julian+=1524)-2439870 )-122.1 )/365.25 );    iy=int( jc-4715 ); jd=365*jc+jc/4;    mm=int(je=long(double(julian-jd)/30.6001))-1; if( mm>12 )mm-=12;    id=int(julian-jd-long(30.6001*je)); if( mm>2 )--iy; if( iy<=0 )--iy;}long julday()  // Функция возвращает сегодняшнее число по Юлианскому исчислению{ time_t iTime=time( NULL );           // выборка секунд от 1 января 1970 года  struct tm *tBlk=localtime( &iTime ); // форматирование даты в местном времени  return julday( tBlk->tm_mon+1,tBlk->tm_mday,tBlk->tm_year+1900 );}static volatile double Daily_Time=0.0;     // Миллисекунды до запуска программыdouble onetime(){ return fmod( (Daily_Time+clock())/(CLK_TCK*3600),24.0); }Event& Event::Now()                              // День и час текущего времени{ time_t iTime=time( NULL );                     // здесь допускается рекурсия  struct tm *tBlk=localtime( &iTime );   D = julday( tBlk->tm_mon+1,tBlk->tm_mday,tBlk->tm_year+1900 );   if( Daily_Time )T=onetime(); else   { T = tBlk->tm_hour + ( tBlk->tm_min+double( tBlk->tm_sec )/60.0 )/60.0;     Daily_Time = T*(CLK_TCK*3600)-clock();   } return *this;}Event& Event::Check(){ if( T>=24.0 ){ D+=long( T/24.0 ); T=fmod( T,24.0 ); } else  if( T<0.0 ){ D-=long( T/-24.0)+1; T=24.0-fmod( -T,24.0 ); } return *this;}//  Процедуры градусно-часовых преобразований           /1991.05.11-2015.01.25///                                             -- оценка округленного интервалаReal AxisStep( Real D )                        // для разметки осевых линий{ Real iPart = floor( D=log10( D ) ); D=exp( (D-iPart)*M_LN10 );  return pow( 10.0,iPart )*( D>6 ?2 : D>3 ?1 : D>1.5 ?0.5:0.2 ); }                                             // M_LN10=2.30258509299404568402
/*  Контроль от -180° до +180°  ||  [-360:360]  =>  A -= floor( A/360.0 )*360.0template <class real> real Angle( const real &A ){ return remainder( A,360 ); }
   {A=fmod(A,360);return A>180?A-360:(A<-180?A+360:A);} // контроль направленияtemplate double Angle<double>( double );                // - лишние операцииtemplate float Angle<float>( float );*/
// двоичный поиск ближайшего левого индекса в поступательной последовательности
//                                                  с учетом знака его прироста
template <class real> int find( const real *A, const real &Ar, int N )
{ int k,i=0; bool d=A[--N]>A[0];
   if( d ){ if( Ar<=A[0] )return 0; else if( Ar>=A[N] )return N-1; }
     else { if( Ar>=A[0] )return 0; else if( Ar<=A[N] )return N-1; }
  while( N-i>1 ){ k=(N+i)/2; if( d ){ if( Ar<A[k] )N=k; else i=k; }
                               else { if( Ar>A[k] )N=k; else i=k; } } return i;
}
template int find<double>( const double *A, const double &Ar, int N );
template int find<float>( const float *A, const float &Ar, int N );
////   Формирование текстовой строки F=0:{-123°46'57"89} 1-deg, 2+min, 3+sec,-hnd//static char *put10( char *s, int d )                 // - составная рекурсия -     { if( d>=10 )s=put10( s,d/10 ); *s++ =d%10+'0'; return s;     }#define put2hnd *s++=d/10+'0',*s++=d%10+'0';         // -- под сотки из цифирекchar *DtoA( Real D, int F, const char *c ){ const Real rnd[]={ 0.499999999,8.333333333e-3,1.388888888e-4 };  static char S[16]; char *s=S; int d,f,l=0;       // счётчик заполненных полей  if( (D=remainder( D,360.0 ))<0.0 ){ D=-D; *s++='-'; } else *s++=' '; // ±180°  if( !F )F=-3; f=F;  if( F>0 )D+=rnd[F-1]; else{ F=-F; D+=rnd[F-1]/100.0; } d=D; D-=d;                     if( d||(!l&&F<2) ){ s=put10( s,d ); strcpy( s,c );                                         s+=strlen( c ); ++l; }  if( F>1 ){d=D*=60; if( d||(!l&&F<3)||(l&&f<0)){put2hnd *s++='\'';++l;} D-=d;}  if( F>2 ){d=D*=60; if( d || f<0 || !l ){ put2hnd *s++='"';  ++l; } D-=d; }  if( f<0 ){d=D*100; if( d )put2hnd } *s=0; return S;}//   Разбор строчки с градусами, со свертыванием с минутами и секундами в число//static char* getright( char *s, Real& D ){ Real d=1.0; while( *s>='0' && *s<='9' )D+=(*s++ -'0')/(d*=10); return s;}static char* getleft( char *s, Real& D ){ while( *s>='0' && *s<='9' ){ D*=10.0; D+= *s++ -'0'; }  if( *s=='.' || *s==',' )s=getright( ++s,D ); return s;}char *AtoD( char *S, Real& _D )           // на выходе следующее свободное поле{ Real D=0.0,m;      char c,*s,*rs=S;           // в OEM есть градусы ° как 248  short n=0,sign=0; while( *rs && *rs<=' ' )++rs; // остальное как в Ascii-1251    if( !(*rs) )return rs;                        // пустая строка пропускается
    if( *rs=='-' )sign=1;                         // знак отделяется от разбора    if( *rs=='+' || sign )++rs;  Rept:  rs=getleft( s=rs,m=0.0 ); rs=UtR( c,rs ); // учетом кодировки UTF-8    switch( c )    { case 248: //0xF8: // case '°'=248:      case ':' : if( n<1 ){ n|=1,D+=m;      goto Rept; } break;      case '\'': if( n<2 ){ n|=2,D+=m/60;   goto Rept; } break;      case '"' : if( n<4 ){ n|=4,D+=m/3600; goto Rept; } break;      default  : if( !n )D=m; else          // повторное считывание      { rs=getright( s,m=0.0 );             // - ничего не попишешь        if( n&4 )D+=m/3600; else if( n&2 )D+=m/60; else D+=m;    } } if( sign )D=-D; _D=D; return rs;}