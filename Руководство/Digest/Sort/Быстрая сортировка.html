<html><head><meta charset="UTF-8"/>
<title>Быстрая сортировка</title>
<link rel="shortcut icon" href="../cpp.ico"/>
<base href="http://neerc.ifmo.ru/wiki/" target="_blank">
</head>
<body>
<h1 id="firstHeading" class="firstHeading" lang="ru">Быстрая сортировка</h1>
<div id="bodyContent" class="mw-body-content">
Материал из Викиконспекты<br>
Перейти к: <a href="#mw-head">навигация</a>, <a href="#p-search">поиск</a>
<p><b>Быстрая сортировка</b> (англ. <i>quick sort</i>, сортировка Хоара) — один из самых известных 
и широко используемых алгоритмов сортировки. Среднее время работы O(n\log{n}), что является асимптотически
оптимальным временем работы для алгоритма, основанного на сравнении. Хотя время работы алгоритма для массива
из n элементов в худшем случае может составить Θ(n2), на практике этот алгоритм является одним из самых быстрых.
</p>
<div id="toc" class="toc"><h2>Содержание</h2>
<ul><li><a href="#A10">1 Алгоритм</a></li>
    <li><a href="#A20">2 Псевдокод</a>
    <ul><li><a href="#A21">2.1 Разбиение массива</a></li></ul></li>
    <li><a href="#A30">3 Асимптотика</a>
    <ul><li><a href="#A31">3.1 Худшее время работы</a></li>
        <li><a href="#A32">3.2 Способ построить массив с максимальным количеством сравнений при выборе среднего элемента в качестве опорного</a></li>
        <li><a href="#A33">3.3 Способ построить массив с максимальным количеством сравнений при детерминированном выборе опорного элемента</a></li>
        <li><a href="#A34">3.4 Среднее время работы</a></li></ul></li>
    <li><a href="#A40">4 Модификации</a>
    <ul><li><a href="#A41">4.1 Нерекурсивная реализация быстрой сортировки</a></li>
        <li><a href="#A42">4.2 Улучшенная быстрая сортировка</a></li>
        <li><a href="#A43">4.3 Быстрая сортировка с разделением на три части</a></li>
        <li><a href="#A44">4.4 Параллельная сортировка</a></li>
        <li><a href="#Introsort">4.5 Introsort</a></li></ul></li>
    <li><a href="#A50">5 См. также</a></li>
    <li><a href="#A60">6 Источники информации</a></li>
</ul>
</div>

<h2><span id="A10">Алгоритм</span></h2>
<p>Быстрый метод сортировки функционирует по принципу "разделяй и властвуй".
</p>
<ul>
<li>Массив a[l…r] типа T разбивается на два (возможно пустых) подмассива a[l…q] и a[q+1…r], таких, что каждый элемент a[l…q] меньше или равен a[q], который в свою очередь, не превышает любой элемент подмассива a[q+1…r]. Индекс вычисляется в ходе процедуры разбиения.</li>
<li>Подмассивы a[l…q] и a[q+1…r] сортируются с помощью рекурсивного вызова процедуры быстрой сортировки.</li>
<li>Поскольку подмассивы сортируются на месте, для их объединения не требуются никакие действия: весь массив a[l…r] оказывается отсортированным.</li>
</ul>

<h2><span id="A20">Псевдокод</span></h2>
<pre>  <b>void</b> quicksort(a: <b>T</b>[n], <b>int</b> l, <b>int</b> r)
     <b>if</b> l &lt; r
        <b>int</b> q = partition(a, l, r)
        quicksort(a, l, q)
        quicksort(a, q + 1, r)
</pre>
<p>Для сортировки всего массива необходимо выполнить процедуру quicksort(a,0,length[a]−1)
</p>
<h3><span id="A21">Разбиение массива</span></h3>
<p>Основной шаг алгоритма сортировки — процедура {partition}, которая переставляет элементы массива a[l…r] типа T нужным образом.
Разбиение осуществляется с использованием следующей стратегии. Прежде всего, в качестве разделяющего элемента произвольно выбирается элемент
a[(l+r)/2]. Далее начинается просмотр с левого конца массива, который продолжается до тех пор, пока не будет найден элемент,
превосходящий по значению разделяющий элемент, затем выполняется просмотр, начиная с правого конца массива, который продолжается до тех пор,
пока не отыскивается элемент, который по значению меньше разделяющего. Оба элемента, на которых просмотр был прерван, очевидно,
находятся не на своих местах в разделенном массиве, и потому они меняются местами. Так продолжаем дальше, пока не убедимся в том,
что слева от левого указателя не осталось ни одного элемента, который был бы больше по значению разделяющего, и ни одного элемента
справа от правого указателя, которые были бы меньше по значению разделяющего элемента.
</p>
<p>Переменная v сохраняет значение разделяющего элемента a[(l+r)/2], a i и j представляет собой, соответственно, указатели левого и правого просмотра.
Цикл разделения увеличивает значение i и уменьшает значение j на 1, причем условие, что ни один элемент слева от i не больше v и ни один элемент справа
от j не меньше  v, не нарушается. Как только значения указателей пересекаются, процедура разбиения завершается.</p>
<pre>  <b>int</b> partition(a: <b>T</b>[n], <b>int</b> l, <b>int</b> r)
     <b>T</b> v = a[(l + r) / 2]
     <b>int</b> i = l
     <b>int</b> j = r
     <b>while</b> (i ⩽ j)
        <b>while</b> (a[i] &lt; v)
           i++
        <b>while</b> (a[j] &gt; v)
           j--
        <b>if</b> (i ⩾ j)
           <b>break</b>
        swap(a[i++], a[j--])
     <b>return</b> j
</pre>
<h2><span id="A30">Асимптотика</span></h2>
<h3><span id="A31">Худшее время работы</span></h3>
<p>Предположим, что мы разбиваем массив так, что одна часть содержит n−1 элементов, а вторая — 1. Поскольку процедура разбиения занимает время Θ(n), для времени работы T(n) получаем,
что при максимально несбалансированном разбиении время работы составляет Θ(n2). В частности, это происходит, если массив изначально отсортирован</p>

<h3><span id="A32">Способ построить массив с максимальным количеством сравнений при выборе среднего элемента в качестве опорного</span></h3>
<p>В некоторых алгоритмах быстрой сортировки в качестве опорного выбирается элемент, который стоит в середине рассматриваемого массива.
Рассмотрим массив, на котором быстрая сортировка с выбором среднего элемента в качестве опорного сделает Θ(n2) сравнений.
Очевидно, что это будет достигаться при худшем случае (когда при каждом разбиении в одном массиве будет оказываться 1 а в другом n−1 элемент).

Заполним сначала массив a
 длины n
 элементами от 1
 до n
, затем применим следующий алгоритм (нумерация с нуля)::
</p>
<pre>  <b>void</b> antiQsort(a: <b>T</b>[n])
     <b>for</b> i = 0 <b>to</b> n - 1
        swap(a[i], a[i / 2])
</pre>
<p>Тогда на каждом шаге в качестве среднего элемента будет ставиться самый крупный элемент.
</p>
<p>При выполнении partition
 делается Θ(n)
 сравнений из-за того, что с помощью индексов i
 и j
 мы проходим в лучшем случае Ω(n)
 элементов (если функция прекращает свою работу, как только индексы встречаются), в худшем случае O(2n)
 элементов (если оба индекса полностью проходят массив). При каждом изменении индекса делается сравнение, значит, процедура partition
 делает Θ(n)
 сравнений с точностью до константы.
</p>
<p>Рассмотрим, какой элемент будет выбираться опорным на каждом шаге. antiQsort
 на каждом шаге меняет местами последний и центральный элементы, поэтому в центре оказывается самый крупный элемент. А partition
 делает абсолютно симметричные этой процедуре операции, но в другую сторону: меняет местами центральный элемент с последним, так что самый крупный элемент становится последним, а затем выполняет на массиве длины на один меньшей ту же операцию. Получается, что опорным всегда будет выбираться самый крупный элемент, так как antiQsort
 на массиве любой длины будет выполнять операции, обратные partition
. Фактически, partition
 — это antiQsort
, запущенная в другую сторону. Также стоит отметить, что процедура разбиения будет делать на каждом шаге только одну смену элементов местами. Сначала i
 дойдет до середины массива, до опорного элемента, j
 останется равным индексу последнего элемента. Затем произойдет swap
 и i
 снова начнет увеличиваться, пока не дойдет до последнего элемента, j
 опять не изменит свою позицию. Потом произойдет выход из while
.
</p><p>Разбиение массива будет произведено Θ(n)
 раз, потому что разбиение производится на массивы длины 1
 и n−1
 из-за того, что на каждом шаге разбиения в качестве опорного будет выбираться самый крупный элемент (оценка на худшее время работы доказана выше). Следовательно, на массиве, который строится описанным выше способом, выполняется Θ(n)
 partition
 и Θ(n)
 сравнений для каждого выполнения partition
. Тогда быстрая сортировка выполнит Θ(n2)
 сравнений для массива, построенного таким способом.
</p>

<h3><span id="A33">Способ построить массив с максимальным количеством сравнений при детерминированном выборе опорного элемента</span></h3>
<p>Рассмотрим алгоритм построения массива, на котором быстрая сортировка с детерминированным выбором опорного элемента будет делать максимальное
(в данном случае — Θ(n2)) количество сравнений. Такое число сравнений достигается при разбиении на массивы длиной 1 и n-1 на каждой итерации.
Создадим массив a длины n, заполненный элементами типа pair. Такой элемент хранит пару значений (val, key), где val — элемент массива, а key — индекс.
Изначально a[i] элемент имеет вид (0, i).
</p><p>Далее, запустим для данного массива алгоритм быстрой сортировки. Сравниваем два элемента типа pair по их значениям val.
На каждом шаге будем выполнять следующие действия: при обращении к i-ому элементу в качестве опорного на шаге под номером k,
присвоим val = n-k+1 для элемента a[i]. Затем выполним шаг сортировки. После завершения работы алгоритма быстрой сортировки,
дополнительно отсортируем получившиеся элементы pair по значениям key. Искомым будет являться массив элементов val в соответствующей последовательности.

<p>На этапе построения мы каждый раз присваивали опорному элементу максимальное значение.
Следовательно, при выполнении {quicksort} алгоритм в качестве опорного
всегда будет выбирать наибольший элемент массива (выборка будет производится в том же порядке
ввиду детерминированности определения опорного элемента).
Таким образом, так как каждый раз массив разбивается на две части — большие или равные опорному элементы и меньшие
его — на каждом шаге имеем разбиение на массивы длины 1 и n-1,
чего мы, собственно, и добивались. При таком выполнении алгоритма происходит Θ(n2)
разделений на два подмассива, и на каждом разделении выполняется Θ(n2) сравнений.
Следовательно, на данном массиве быстрая сортировка работает за Θ(n2)</span>.
</p>
<h3><span id="A34">Среднее время работы</span></h3>
<p>Mатожидание времени работы быстрой сортировки будет O(nlogn).
</p>
<h2><span id="A40">Модификации</span></h2>
<h3><span id="A41">Нерекурсивная реализация быстрой сортировки</span></h3>
<p>Для выполнения быстрой сортировки можно воспользоваться <a href="index.php?title=Стек" title="Стек"> стеком</a>,
в котором в виде сортируемых подмассивов содержится перечень действий, которые предстоит выполнить.
Каждый раз когда возникает необходимость в обработке подмассива, он выталкивается из стека. После разделения массива получаются два подмассива,
требующих дальнейшей обработки, которые и заталкиваются в стек.
Представленная ниже нерекурсивная реализация использует стек, заменяя рекурсивные вызовы помещением в стек параметров функции,
а вызовы процедур и выходы из них — циклом, который осуществляет выборку параметров из стека и их обработку, пока стек не пуст.
Мы помещаем больший из двух подмассивов в стек первым с тем,
чтобы максимальная глубина стека при сортировке N элементов не превосходила величины log n.
</p>
<pre>  <b>void</b> quicksort(a: <b>T</b>[n], <b>int</b> l, <b>int</b> r)
     <b>stack</b>&lt; <b>pair</b>&lt;<b>int</b>,<b>int</b>&gt; &gt; s
     s.push(l, r)
     <b>while</b> (s.isNotEmpty)
        (l, r) = s.pop()
        <b>if</b> (r ⩽ l)
           <b>continue</b>
        <b>int</b> i = partition(a, l, r)
        <b>if</b> (i - l &gt; r - i)
           s.push(l, i - 1)
           s.push(i + 1, r)
        <b>else</b>
           s.push(i + 1, r)
           s.push(l, i - 1)
</pre>
<p>В качестве альтернативного варианта можно использовать обычную рекурсивную версию, в которой вместо того, чтобы после разделения массива вызывать рекурсивно процедуру разделения для обоих найденных подмассивов, рекурсивный вызов делается только для меньшего подмассива, а больший обрабатывается в цикле в пределах этого же вызова процедуры. С точки зрения эффективности в среднем случае разницы практически нет: накладные расходы на дополнительный рекурсивный вызов и на организацию сравнения длин подмассивов и цикла — примерно одного порядка. Зато глубина рекурсии ни при каких обстоятельствах не превысит <span style='display:none'>[math]\log n[/math]</span>, а в худшем случае вырожденного разделения она вообще будет не более <span style='display:none'>[math]1[/math]</span> — вся обработка пройдёт в цикле первого уровня рекурсии.
</p>
<h3><span id="A42">Улучшенная быстрая сортировка</span></h3>
<p>Выбор медианы из первого, среднего и последнего элементов в качестве разделяющего элемента и отсечение рекурсии меньших подмассивов может
привести к существенному повышению эффективности быстрой сортировки. Функция median возвращает индекс элемента, являющегося медианой трех элементов.
После этого он и средний элемент массива меняются местами, при этом медиана становится разделяющим элементом.
Массивы небольшого размера (длиной M = 11 и меньше) в процессе разделения игнорируются, затем для окончания сортировки используется
<a href="index.php?title=Сортировка_вставками" title="Сортировка вставками"> сортировка вставками</a>.
</p>
<pre>  <b>const int</b> M = 10
  <b>void</b> quicksort(a: <b>T</b>[n], <b>int</b> l, <b>int</b> r)
     <b>if</b> (r - l ⩽ M)
        insertion(a, l, r)
        <b>return</b>
     <b>int</b> med = median(a[l], a[(l + r) / 2], a[r])
     swap(a[med], a[(l + r) / 2])
     <b>int</b> i = partition(a, l, r)
     quicksort(a, l, i)
     quicksort(a, i + 1, r)
</pre>
<p>Вообще, можно применять любые эвристики по выбору опорного элемента. Например, в стандартной реализации в Java в качестве разделяющего выбирается средний из 7 элементов, равномерно распределённых по массиву.
</p>
<h3><span id="A43">Быстрая сортировка с разделением на три части</span></h3>
<p>Когда в сортируемом массиве имеется множество повторяющихся ключей предыдущие реализации быстрой сортировки
можно существенно улучшить. Например массив, который состоит из равных ключей, вовсе не нуждается в дальнейшей
сортировке, однако предыдущие реализации продолжают процесс разделения, подвергая обработке все более мелкие 
подмассивы, независимо от того, насколько большим является исходный файл.
</p>
<p>В основу программы положено разделение массива на три части:
на элементы,меньшие разделяющего элемента a[l]…a[i],
элементы, равные разделяющему элементу a[i+1]…a[j−1],
и элементы большие разделяющего элемента a[j]…a[r].
После этого сортировка завершается двумя рекурсивными вызовами.
</p>
<p>Элементы массива равные разделяющему элементу находятся между l и p и между q и r. В разделяющем цикле, 
когда указатели просмотра перестают изменяться и выполняется обмен значениями i и j, каждый из этих
элементов проверяется на предмет равенства разделяющему элементу. Если элемент, который сейчас находится слева,
равен разделяющему элементу, то при помощи операции обмена он помещается в левую часть массива, если элемент,
который сейчас находится справа, равен разделяющему элементу, то в результате операции обмена он помещается
в правую часть массива. После того как указатели пересекутся, элементы, равные разделяющему элементу и находящиеся
на разных концах массива, после операции обмена попадают в свои окончательные позиции. После этого указанные ключи
могут быть исключены из подмассивов, для которых выполняются последующие рекурсивные вызовы.
</p>
<pre>  <b>void</b> quicksort(a: <b>T</b>[n], <b>int</b> l, <b>int</b> r)
     <b>T</b> v = a[r]
     <b>if</b> (r ⩽ l)
        <b>return</b>
     <b>int</b> i = l
     <b>int</b> j = r - 1
     <b>int</b> p = l - 1
     <b>int</b> q = r
     <b>while</b> <i>(i ⩽ j)</i>
        <b>while</b> (a[i] &lt; v) i++
        <b>while</b> (a[j] &gt; v) j--
        <b>if</b> (i ⩾ j) <b>break</b>
        swap(a[i], a[j])
        <b>if</b> (a[i] == v) p++
           swap(a[p], a[i])
           i++
        <b>if</b> (a[j] == v) q--
           swap(a[q], a[j])
           j--
     swap(a[i], a[r])
     j = i - 1
     i++
     <b>for</b> (<b>int</b> k = l; k ⩽ p; k++, j--) swap(a[k], a[j])
     <b>for</b> (<b>int</b> k = r - 1; k ⩾ q; k--, i++) swap(a[k], a[i])
     quicksort(a, l, j)
     quicksort(a, i, r)
</pre>
<h3><span id="A44">Параллельная сортировка</span></h3>
<p>Еще одной оптимизацией является <a href="index.php?title=PSRS-сортировка" title="PSRS-сортировка">параллельная сортировка</a> на основе быстрой.
Пусть, исходный набор данных расположен на первом процессоре, с него начинается работа алгоритма. Затем исходный массив окажется разделенным на две части,
меньшая из которых передастся другому свободному процессору, большая останется на исходном для дальнейшей обработки. Далее обе части опять будут разделены
и опять на двух исходных останутся большие части, а меньшие отправятся другим процессорам. В этом заключается ускорение алгоритма.
При задействовании всех процессоров, все части параллельно будут сортироваться последовательным алгоритмом.
</p>
<h3><span id="Introsort">Introsort</span></h3>
<p>Для предотвращения ухудшения времени работы быстрой сортировки до O(n2) при неудачных входных данных,
также можно использовать алгоритм сортировки Introsort. Он использует быструю сортировку и переключается на
<a href="index.php?title=Сортировка_кучей" title="Сортировка кучей">пирамидальную сортировку</a>,
когда глубина рекурсии превысит некоторый заранее установленный уровень (например, логарифм от числа сортируемых элементов).
Так как после нескольких итераций быстрой сортировки с применением разных эвристик массив с большей вероятностью окажется
«почти отсортированным», то пирамидальная сортировка может довольно быстро закончить дело. Также, пирамидальная сортировка
хороша тем, что требует O(1) дополнительной памяти, в отличие от, например, сортировки слиянием, где потребуется O(n) дополнительной памяти.
</p>
<h2><span id="A50">См. также</span></h2>
<ul><li> <a href="index.php?title=Сортировка_Шелла" title="Сортировка Шелла">Сортировка Шелла</a></li>
<li> <a href="index.php?title=Сортировка_кучей" title="Сортировка кучей">Сортировка кучей</a></li>
<li> <a href="index.php?title=Сортировка_слиянием" title="Сортировка слиянием">Сортировка слиянием</a></li>
<li> <a href="index.php?title=Timsort" title="Timsort">Timsort</a></li>
<li> <a href="index.php?title=Smoothsort" title="Smoothsort">Smoothsort</a></li>
<li> <a href="index.php?title=PSRS-сортировка" title="PSRS-сортировка">PSRS-сортировка</a></li></ul>
<h2><span id="A60">Источники информации</span></h2>

<ul><li> <a href="http://en.wikipedia.org/wiki/ru:Википедия — Быстрая сортировка" class="extiw" title="wikipedia:ru:Быстрая сортировка">Википедия — Быстрая сортировка</a></li>
<li> <a href="http://en.wikipedia.org/wiki/en:Quicksort" class="extiw" title="wikipedia:en:Quicksort">Wikipedia — Quicksort</a></li>
<li> <a href="http://en.wikipedia.org/wiki/en:Introsort" class="extiw" title="wikipedia:en:Introsort">Wikipedia — Introsort</a></li>
<li> <i>Т.Кормен, Ч.Лейзерсон, Р.Ривест</i>: Алгоритмы: построение и анализ глава 7</li>
<li> <i>Р.Седжвик</i>: Фундаментальные алгоритмы на С++ части 1 - 4</li>
</ul>
Источник — «<a dir="ltr" href="index.php?title=Быстрая_сортировка&amp;oldid=85137">http://neerc.ifmo.ru/wiki/index.php?title=Быстрая_сортировка&amp;oldid=85137</a>»
<hr width=50% align=left>
</body>
</html>
