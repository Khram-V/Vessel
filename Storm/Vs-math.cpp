//
//   Здесь собраны все инициализации и собственно расчетные операции
//      по моделированию динамики корпуса на волнении
/*                                                          ©2020-11-21 ‏יְרוּשָׁלַיִם
  ==
  == геометрия корпуса, состояние движения и маршрутные записи курса и скорости
  ==
  Real Length,Breadth,Draught,    // конструктивные длина, ширина и осадка  [м]
       Course,dCs,  // курс корабля и обратное время для полуциркуляции п·dT/30
        Speed,cSp;  // настоящая и устанавливаемая скорость хода корабля  [м/с]
  Vector Locate;    // местоположение корабля для отсчётов волновых полей   [м]
  Flex Route,       // маршрут - траектория контролируемого хода корабля  МБ[м]
       Rate,        // скорости смещения корпуса в корабельном базисе   КБ[м/с]
       Head,Whirl,  // и вращательные движения корпуса в углах Крылова  [р,р/с]
       Mix;         // сохраняемые величины для повторных расчётов в протоколах
                    // Mix.z - уровень моря на миделе; у - курс; x - скорость..
  byte Statum;  //   0 - кинематическое позиционирование со скольжением корпуса
                //       над волнением по хордам четырёх точек склона, иначе:
                //   1 - объёмное гравитационное всплытие: борт-киль-вертикаль
                //   2 - гидростатическое давление в волне на смоченной обшивке
                //   3 ÷ ≈ вихреисточники обтекания корпуса набегающим потоком
                //   4 - компоненты скорости на обшивке под волновыми гребнями
                //  ~~ ~ полные потоки в механике отражения волн(в перспективе)
                //  ++ ~ обтекание корпуса с трохоидальными волнами по глубине
                //  ~~ - динамическое изменение тензора инерции и центра масс
                //  ~~ - перепады давления по градиентам поверхности ватерлинии
  unsigned Educt; // = управление выводами результатов мореходного эксперимента
                // 1 - ходкость и отклонение от заданной скорости хода
                // 2 - направление движения и наибольшее рыскание на курсе
                // 4-8-16 - экстремумы вертикальной, бортовой и килевой качки
                // 32-64-128 -вертикальные ускорения на корме, миделе и по носу
                // 512 - 0х200 - признак необходимости записи только превышений
  byte DrawMode; --  0 - ватерлиния строится при любом графическом раскладе
                     1 - прорисовываются только собственно штевни и шпангоуты
                     2 - оставляется подводная часть со шпангоутами над водой
                     3 - весь корпус прорисовывается целиком отчасти прозрачным
                   х04 - тоже, без обшивки и только с триангуляционными ребрами
   ++              х08 - исходный вариант: одно поле графиков и картушка справа
   -- размерения и динамические параметры корпуса корабля (Volume=0-обновление)
   -- локальная корабельная система координат определяется в составе структуры
   -- Hull::Base и включает координаты пространственного местоположения
   -- Point{X,Y,Z} и тензор тривекторов поворотов Matrix::Vector{x,y,z}
   --
  Real hX,// поперечная метацентрическая высота задаёт аппликату центра тяжести
      Volume,  iV, // исходное водоизмещение, мгновенный погруженный объем V м³
      Surface, iS, // подводная и смоченная поверхность корпуса            S м²
      Floatage,iF, // исходная и действующая площадь ватерлинии            F м²
      sT,          // интервал времени для графиков с кинематикой XYZ-качки сек
      Trim,        // дифферент задается простым смещением центра величины[рад]
      Kv;          // доля сброса отрицательного давления в парадоксе Даламбера
  Vector Ofs,      // внутренние смещения отсчетов по миделю и ватерлинии {x,z}
      Gravity,     // + центр тяжести в локальных корабельных координатах    G
      Buoyancy,  vB, // координаты центра величины,центра объема корпуса     cB
      Floatable, vF, // центр площади исходной и действующей ватерлинии      cF
      Metacenter,vM, // начальный + текущий поперечные метацентры    в КБ Zm(x)
                 vW, // нормаль интегро-осредненной площади ватерлинии      (δ)
                 vD, // условный центр сосредоточения гидродинамических пар-сил
                 vC, // динамический центр пространственного движения корпуса
                 vS, // накопительный вектор сил от перепада уровня моря  [H/ρ]
                 vR; // поворотный момент от криво-наклонной ватерлинии   [Н·м]
                     // с оценкой мгновенной метацентрической высоты в МБ! h(z)
  Matrix inWater,mW, // моменты инерции площади действующей ватерлинии     I м⁴
         inMass; //,mM; моменты инерции исходного и смещенного корпуса     G м⁴
  Vector nF,nM, // относительные коэффициенты угловых и поступательных движений
       muF,muM; // обобщённые параметры демпфирования - задаваемые извне
                   -- демпфирование (>0) до исключения(=1) скорости качки
      // под большими углами крена и до опрокидывания сопротивление утраивается
*/
#include "Aurora.h"   // объекты и производные операции с корпусом на волнении
                      //   ++ дополнения графической среды OpenGL->Window-Place
                      //  Hull: координатные оси корабельного базиса морской СК
static Vector         //! КБ - локальный корабельный базис; МБ - морской базис
//     vBi,           //  положение центра величины из предыдущего шага времени
       Vship,Wship;   //   скорость хода и вектор момента вращения корпуса в КБ

void
Hull::ThreeInitial()  // начальная очистка всех величин динамических параметров
{ vD=vC;              // гидродинамический центр с предыдущего расчётного такта
  iV=iS=iF=0.0;       // скалярные собраны в кучу, векторные - все производные
  mW=0.0; //mM=0.0;   // тензорные объекты в том же ранге срочных перерасчетов
  vW=Zenit;           // нормаль интегро-осредненной площади ватерлинии     (δ)
  vB=vP=vF=Zero;      // сумматоры для задействования ранее вычисленных величин
  vM=vS=vR=Zero;      // метацентр, силы и моменты от перепадов уровней у борта
  if( !Storm->Kt )    // если самое первое обращение - вместо конструктора Hull
  { Volume=Surface=Floatage=0;
    Vship=Wship=Gravity=vC=dV=Zero; inWater=0.0; inMass=0.0;
  } else
  { Vship=( (Route[-1]-Route[-2])/Ts )/Tensor(*this);
    Wship=Whirl[-1];  // скорости выше реальные и по расчётам вращательные в КБ
  }
}
void Hull::Three( int Level,  // -2-днище; -1-вода; 0-в-линия; 1-воздух; 2-борт
    _Vertex a,_Vertex b,_Vertex c ) //! динамический перерасчет параметров
{ if( Level<=0 )                    // борт, общекорабельная архитектура мимо
  { _Point A=Point( a ),B=Point( b ),C=Point( c );
   Field &Sea=*Storm;
   Vector S =( (a-c)*(b-c) )/2.0;   // нормаль с площадью элемента обшивки в КБ
   Real   W =abs( S );                // площадь малого треугольника на обшивке
    if( W<eps )return;                // -- сброс обнулённого фрагмента
    Vector L =( a + b + c )/3.0,      // центр площади к треугольнику в обшивке
           M = L * 0.75,              // центр объема к элементарному тетраэдру
           Sz=( A-C )*( B-C )/2;      // ориентация в МБ
      //   Sz=( (Point(a)-Point(c))*(Point(b)-Point(c)) )/2; // ориентация в МБ
    Real   V =( c % S )/3.0;          // водоизмещение элементарного тетраэдра
           iV += V;                   // суммирование тетраэдров водоизмещения
           vB += M*V;                 // векторная сборка статических моментов
    if( !(Sea.Kt) )                   // моменты инерции объема/массы корпуса
    { Matrix J;                       // временно из общей механики исключается
      J.x.x = a.y*a.y+b.y*b.y+c.y*c.y + a.z*a.z+b.z*b.z+c.z*c.z
            + a.y*b.y+a.y*c.y+b.y*c.y + a.z*b.z+a.z*c.z+b.z*c.z;
      J.y.y = a.x*a.x+b.x*b.x+c.x*c.x + a.z*a.z+b.z*b.z+c.z*c.z
            + a.x*b.x+a.x*c.x+b.x*c.x + a.z*b.z+a.z*c.z+b.z*c.z;
      J.z.z = a.x*a.x+b.x*b.x+c.x*c.x + a.y*a.y+b.y*b.y+c.y*c.y
            + a.x*b.x+a.x*c.x+b.x*c.x + a.y*b.y+a.y*c.y+b.y*c.y;
      J.x.y=J.y.x = -0.5*( a.x*b.y+a.x*c.y+b.x*c.y + a.y*b.x+a.y*c.x+b.y*c.x )
                         - a.x*a.y - b.x*b.y - c.x*c.y;
      J.x.z=J.z.x = -0.5*( a.x*b.z+a.x*c.z+b.x*c.z + a.z*b.x+a.z*c.x+b.z*c.x )
                         - a.x*a.z - b.x*b.z - c.x*c.z;
      J.y.z=J.z.y = -0.5*( a.y*b.z+a.y*c.z+b.y*c.z + a.z*b.y+a.z*c.y+b.z*c.y )
                         - a.y*a.z - b.y*b.z - c.y*c.z;
      inMass += ( J *= 0.1*V );
    }
    if( Level<0 )     //! гидростатика с гидродинамикой обводов ниже ватерлинии
    { iS += W;        // + скаляр площади смоченной поверхности судовой обшивки
      if( Statum>1 ){ // если внешнее давление на треугольники и пары сил  в КБ
       Vector Cz=L;   // здесь будет местоположение точки действия сил давления
       Point R=out( L );// центр элементарного треугольника в морском базисе МБ
       Real Hz=R.Z;                 // подводная вертикаль центра давления в МБ
        if( Sea.Kt )Hz -= Sea.Value( R ); // добавка к высоте по уровню моря МБ
        if( Hz<-eps && W>eps )   // подводный пересчёт по вертикали центра силы
        { Vector C=Zenit*( Sz/W );  // длина к синусу угла вертикали с нормалью
          if( norm( C )>eps )       // и если треугольник не горизонтален
          { Real az=a.Z-a.w, bz=b.Z-b.w, cz=c.Z-c.w,  // погружение вершин в МБ
            d=( az*(az-bz-cz)/2 + (bz*bz+bz*cz+cz*cz)/6 - sqr( az-Hz ) )/Hz;
            C=( dir( C*Sz ) )*(d/abs( C ));  // к центру действия силы давления
            Cz=in( R-C );                   // возврат в корабельные координаты
        } }         // гидростатика всегда есть в интегралах по судовым обводам
        vS += Hz*S; //  накопительный вектор сил давления треугольников [Н/ρ]КБ
        vR += Hz*( (Cz-Gravity)*S );  //++ пара сил от центра тяжести [Н·м/ρ]KБ
        if( Statum==2 )vP -= Hz*W*Cz; //... к центру действия сил давления воды
        //
        //   Здесь гидростатика дополняется компонентами скоростных потоков для
        //           для взаимовлияния хода, качки и всех штормовых воздействий
        if( Sea.Kt )
        if( Statum>2 ){   // ходовый+волновой - встречный набегающий поток воды
         Vector w= Zero,
                s= S/W,    //  ориентация нормали треугольника в корабельной СК
                v= Vship   // *(1+Breadth/Length/2) - для шара получится 1,5 КБ
                 + Wship*(L-Gravity); // скорость треугольника, правило знаков?
          if( Statum>3 && Sea.Exp.wave ) // подводные волновые воздействия
          {             // выборка скорости течения под волной по координатам R
            Sea.WaveV( Sea.Trun,*(Vector*)(&R),w );    // смещение и скорость
            v -= (w = w/Tensor(*this));                // частицы жидкости в КБ
          }
         Real  nv=s%v;      // нормальная компонента отражаемых корпусом частиц
          if( nv<0 )        // на воде отрицательное давление реализуется плохо
          if( Kv<1.0 )nv*=( 1+(1-Kv)*(s%dir(v)) ); // сброс парадокса Даламбера
          Hz=( norm( s*v )   // касательная компонента набегающего потока воды
             + norm( s*w )   // удвоение скользящей компоненты отражаемой волны
             - norm( v )     // интегральная скорость потока = по ходу корабля
             - copysign( nv*nv,nv ) )/(_g*2.0);   // поток c непротеканием в КБ
          vS += Hz*S;   // накопительный вектор сил давления треугольников в КБ
          vR += Hz*( (L-Gravity)*S );     //++ моменты от исходного центра масс
          vP -= Hz*W*L;                  // к центру действия сил давления воды
        }
      }
    } else        //!  теперь всё это относится к уровню действующей ватерлинии
    { Real        // -- первые две вершины по одному борту, третья - по другому
      s=Sz%Zenit; // площадь элемента ватерлинии в горизонтальном проецировании
      iF += s;    // площадь действующей ватерлинии инвариантна в любом базисе
      vF += L*s;  // момент для вычисления центра площади ватерлинии{x4/3} в КБ
      vW += Sz;   // ещё один векторный элемент интегральной площади ватерлинии
      //    обоснованность задействования перепадов давления на противоположных
      //   бортах не сильно велика, но по эффекту не особо действенна и пагубна
      if( Statum==1 ) //! силы и моменты по уровням на треугольниках ватерлинии
      { Vector F; // элемент силы в глобальной морской системе координат - в МБ
        F = 0.5*( 0.5*( a.w+b.w )-c.w )*Sz/W;              // правило знаков !!
        F.z=0.0;           //-- или горизонтальный компонент дрейфовых сил в MB
        F=F/Tensor(*this); // g -- величина силы-ускорения вместе с реакцией КБ
        vS+=F;             // величина горизонтальной сдвиговой силы в КБ [Н/ρ]
        vR+=(L-Gravity)*F; // разворачивающий момент дрейфа на склоне волн[Н·м]
      }
#if 0
     Real ar=hypot( a.y,a.z ),            // + простая дистанция от оси абсцисс
          br=hypot( b.y,b.z );            // момента инерции площади ватерлинии
      W = fabs( a.x*br-b.x*ar )/12.0;     // иная площадь элементарной площадки
      mW.x.y=                             // моменты инерции площади ватерлинии
      mW.y.x+=( a.x*br/2 + a.x*ar + b.x*br + b.x*ar/2 )*W;     // упорядоченные
      mW.x.x+=(  ar*ar  +  ar*br  +  br*br  )*W;               // фрагменты
      mW.y.y+=( a.x*a.x + a.x*b.x + b.x*b.x )*W;               // ватерлинии
#else
      s /= 6.0; // W/6.0;                 // иная площадь элементарной площадки
      mW.x.y=                             // моменты инерции площади ватерлинии
      mW.y.x+=s*( a.x*b.y/2 + a.x*a.y + b.x*b.y + b.x*a.y/2 ); // упорядоченные
      mW.x.x+=s*( a.y*a.y + a.y*b.y + b.y*b.y );               // фрагменты
      mW.y.y+=s*( a.x*a.x + a.x*b.x + b.x*b.x );               // ватерлинии
#endif
    }
  }
}
//!  рассматривается динамика корпуса корабля с переменным водоизмещением и
//!  деформируемыми моментами инерции в условиях интенсивного морского волнения
//
void           // метацентрическая высота hX определяется в исходных данных [м]
Hull::ThreeFixed() // постобработка всех треугольников, фиксация первой статики
{ //
  //  корпус может погрузиться iF==0 или выскочить из воды iV==0
  //             метацентрические расчеты опасны делениями на площади и объёмы
 Field &Sea=*Storm;
 bool isWaterPlane=iF>eps,  // Floatage/32 существование действующей ватерлинии
      isDisplacement=iV>eps; // Volume/64  потеря поверхности воды после взлёта
  if( !isWaterPlane )                // если нет площади действующей ватерлинии
  { if( !(Sea.Kt) )Break( "Ошибка инициализации\n\t(нет ватерлинии)" );
    vW=Zenit;        // направление вектора всплытия вертикально вверх
    vF=Floatable;    // взамен нуля возврат исходного центра площади ватерлинии
    vM=Metacenter;   // метацентра нет, и пусть также на начальной остойчивости
    mW=inWater;      // может быть нулём или центром базиса по определению
    if( !isDisplacement )vC=vP=vB=Gravity; // летучий голландец парит по волнам
  }
  if( isDisplacement ) // судно в водоизмещающем положении на поверхности моря
  { vB /= iV;     // корабельные координаты центра величины(=подводного объема)
    vF /= iF;     // условный центр площади ватерлинии по горизонту,  тоже в КБ
    vW = dir( vW ); // интегральная нормаль к площади действующей ватерлинии КБ
    mW = Steiner( mW,vF );  // моменты инерции исходной площади ватерлинии I м⁴
    //
    // !..не приводим моменты инерции к центру масс и центру площади ватерлинии
    //                      // всё в исходной корабельной системе координат ...
//  vP /= 2.0;    // ... что-то там то ли непонятно, то ли не совсем "чисто"...
    if( Statum<=1 )vP=vB; else
    if( Statum==2 )vP/=abs(vS)*2;  // сразу весь вектор сил давления на обшивке
    else vP=vB+vP/iV/2; // или гидродинамическая поправка по Бернулли-Торричелли
    //
    //  Здесь уместно выставить динамический центр движения корпуса при качке
    //
    vC = (Gravity*Volume + vP*iV )/( Volume+iV );  // что если без премудростей
  }
  else
  if( !(Sea.Kt) )Break( "Ошибка инициализации\n\t(нет водоизмещения)" );

  if( !(Sea.Kt) )  //! фиксация начальных гидростатических характеристик   в КБ
  { Volume=iV;     // исходное водоизмещение, мгновенный погруженный объем V м³
    Surface=iS;    // подводная и смоченная поверхность корпуса            S м²
    Floatage=iF;   // исходная и действующая площадь ватерлинии            F м²
    Buoyancy=vB;   // координаты центра величины,центра объема корпуса    cB м
    Gravity=vB;    // центр тяжести в локальных корабельных координатах    G м
    vM.z=hX;     // в первом вхождении метацентрическая высота задается явно
    vM.x=vB.z+mW.x.x/Volume;               // аппликата поперечного метацентра
    vM.y=vB.z+mW.y.y/Volume;               // продольного метацентра, дифферент
    Metacenter=vM; // аппликаты теоретических и текущих метацентров   Zm,ZM,h м
    Gravity.z=vM.x-hX; // аппликата центра масс встанет ниже метацентра   hX м
    Floatable=vF;  // центр площади исходной и действующей ватерлинии      cF м
    inWater=mW;    // моменты инерции исходной площади ватерлинии          I м⁴
    inMass=Steiner( inMass,vB,Gravity ); // + инерции массы/объема корпуса G м⁵
    Sea.Kt=1;                           // = переходит сначала на ЦВ затем к ЦТ
    Head[0].z=-Course;// углы геометрические, курс навигационно-географический
    Mix[0].z=Sea.Value( out( Zero ) ); Mix[0].y=Course;
    DampInit();
  } //! Kt≠0 - предотвращает повторы вычислений начальных данных по корпусу
  else
  { Vector A=Tensor(*this)*vB,          // Во внешней морской системе координат
           B=Tensor(*this)*Gravity;     // действующих центров по полной массе
    vM.x = A.z + mW.x.x/Volume;         // аппликата поперечного метацентра
    vM.y = A.z + mW.y.y/Volume;         // продольного метацентра, дифферент
    vM.z = vM.x-B.z;       // hX(z) мгновенное значение метацентрической высоты
} }
//!    динамика корпуса под действием внешних сил и моментов волновой природы
//        ~~ здесь вычислительный шаг во времени задаются по куранту для самых
//           быстрых волн, и еще предстоит это поправить на динамику корабля
//!    оси угловой качки сводятся к центру тяжести с аппликатой мгновенного
//     центра величины (погруженного объёма) в корабельной системе координат
//     (иначе неадекватные скорости течений вблизи обшивки)
//
Hull& Hull::Movement() // шаг во времени Ts устанавливается в Field::Simulation
{ Vector V=Rate[-1],   // вектор полной скорости хода, качки и дрейфа в КБ
        W=Whirl[-1],  // и мгновенная угловая скорости движения корпуса корабля
    Direct=Head[-1], // отсчёты действующих углов x-крен y-дифферент z-рыскание
    A,B,C,D,E,       // крестовой шаблон на взволнованной поверхности моря
    R,U; //,dV=Zero; // действующий градиент наклона волновой поверхности
  Field &Sea=*Storm;
  //
  //  быстрый градиент волнового склона по кресту четырех противоположных точек
  //
  if( Statum<2 )  // скользящая кинематика по направлению действия объемных сил
  { //Vector A,B,C,D,E;
    A = Sea.Locas( out( Zero ) );            // пять точек в корабельном базисе
    B = Sea.Locas( out((Vector){Length/3}))-A;    // градиент инвариантен любым
    C = Sea.Locas( out((Vector){Length/-3}))-A;      // ориентациям ортогоналей
    D = Sea.Locas( *(Point*)( &(R=A+(E=((Breadth/Length/2)*(C-B))*Zenit))) )-A;
    E = Sea.Locas( *(Point*)( &(R=A-E) ) )-A;
    R = A+(B+C+D+E)/5.0;              // == у всех треугольников одинаковый вес
    U = dir( B*D + D*C + C*E + E*B )  // усреднённый вектор в морском базисе МБ
      * rolZ( -Direct.z );            // c выбором направления по курсу корабля
  }               //
  if( !Statum )   //! свободно-жесткий вариант (°) лагом/вразрез/носом на волну
  { // простое статическое касание поверхности склонов волн половинных размеров
    //+ реализовано гравитационно-инерционное скольжение по склонам волн
    //  затем вычисляются аппликаты волн по неким габаритным размерам корпуса
 // U = vW * rolZ( -Direct.z );    // к случаю интегрального градиента
         // после смены курса определяем местоположение оконечностей(без качки)
    A = B - C;                    // плечо на линии фиксации скорости потока
    Sea.WaveV( Sea.Trun,B,B );    // скорость потока в носовой оконечности
    Sea.WaveV( Sea.Trun,C,C );    // скорость потока в кормовой оконечности
    Direct.z +=(A*(B-C)).z*Ts/norm( A ); // скорости к плечу = угловая скорость
    Direct.y = atan2(  U.x,U.z );  // уточняющий перерасчёт для угла дифферента
    Direct.x = atan2( -U.y,U.z );  // подборка нового фиксированного угла крена
      axiZ( Direct.z );            // рыскание: в три угла: курс-дифферент-крен
    Rotate( Direct.y,y );          // +дифферент: приведение положения корпуса
    Rotate( Direct.x,x );          // +крен: на условно больших углах поворотов
    V.x += Direct.y * _g*Ts;       // ускорение и скорость скользящего движения
    V.y -= Direct.x * _g*Ts/2;     //             по градиенту волнового склона
    V.z = ( R.z-Z )/Ts;            // скорость по вертикальной качке
    Z = R.z;                       // изменение аппликаты посадки на миделе КВЛ
    W = (Direct-Head[-1])/Ts;      // скорость изменения курса и углов качки
    R = 0; //Tensor(*this)*(W*Ts); // чтоб без дополнений в динамике качки MБ
    dV= Zero;
  }
  //  изначально эксперимент строился только на главных компонентах архимедовых
  //  сил всплытия по вертикали, как бортовая, килевая и вертикальная качка/нет
  //   и все другие варианты объёмной гидро(статической)динамической постановки
  //                          корпуса корабля на морскую волну большой крутизны
  else
  { Vector B=vS; // суммарное действие всех сил давления у смоченной обшивки КБ
    //
    //      вычисления соотносятся с гравитационным центом тяжести и мгновенным
    //  или действующим центром величины, при этом внешние силы определяются во
    //  внешней морской системе координат, в то время как реакция  и приращения
    //  скоростей в локальном корабельном базисе (как-то так видится с мостика)
    //                   корабельная система координат (КБ) - корабельный базис
    //
    //                           гравитационная разность чисто по водоизмещению
    if( Statum==1 )B += ( ( iV*vW.z )*vW )/Tensor(*this);   // с переходом в КБ
    //
    //       объёмные или поверхностные силы Архимедового всплытия без ρ/ρ в КБ
    //                        водоизмещение - гравитационная сила массы корпуса
    //
    dV = B/Volume - Zenit/Tensor( *this);  // нормированное к единице ускорение
    if( norm( dV )>1.0 )dV=dir( dV );  // максимум ускорения свободного падения
    V += dV *= _g*Ts;         // приращение скоростей поступательной качки [КБ]
    //
    //! бортовая, килевая качка и рыскание - дрейф: F=ρ∙g∙h∙S/2; a=F/V; dV=a∙dt
    // здесь центры масс и величины отмеряются относительно исходной ватерлинии
    //  плечо центра тяжести относительно мгновенно-переменного центра величины
    //
    R = vB-Gravity;     // большое плечо для момента архимедового всплытия в КБ
    //
    // Волновые воздействия задаются архимедовыми силами всплытия по градиентам
    //    поверхностей равных давлений, и с величиной погруженной части корпуса
    // Вектор сил тяжести, проходящий через динамический центр,
    //    не создает никаких кренящих моментов
    //
    //!  ~~ если корпус выходит из воды, то волновое воздействие прекращается
    //   установка внешней гидростатики в местной корабельной системы координат
    //
    if( Statum==1 )
      B = _g*( R*B     // ω=ε·t большие архимедовы моменты в корабельном базисе
        + vS*( Gravity-vF ) );  // ? момент вращений от дрейфовых сдвигов на ВЛ
    else                        // ? здесь или центр тяжести или центр величины
      B=_g*vR;                 // свободная качка и рыскание на склонах волн /ρ
    //
    // боковые смещения полностью гасятся моментом простого крена на циркуляции
    // таким образом пусть любое ускорение центра масс образует момент пары сил
    //                 относительно действующего центра величины (не от осадки)
    //                                      и плечо в морскую систему отсчётов
    if( Route.len>3 )
      B += (Volume/Ts)*(R*((Route[-1]-2.0*Route[-2]+Route[-3])/Tensor(*this)));
    //
    //  Моменты в ускорения поворотов -> скорости вращения -> угловые положения
    //
    W += Ts*(B/Tensor(inMass)); // угловые дифференциалы приращения поворотов/ρ
                            // суммирование скоростей крена.дифферента.рыскания
    { Real w=max( fabs( W.x ),max( fabs( W.y ),fabs( W.z ) ) );
      if( w>_Pi/6.0 )W*=_Pi/w/6.0; //_Pd/6 полный оборот ≈6 сек \оверкиль ≈3сек
    }
    U = W; U &= W; U &= muM*Ts;   // большие скорости ослабляются степенью куба
    W.x *= (1-tanh(U.x)/2)*nM.x*(1.0-sqr(Direct.x*0.5625/_Pi)); // учетверённое
    W.y *= (1-tanh(U.y)/2)*nM.y;  // подторма́живание при оверкиле, затем другие
    W.z *= (1-tanh(U.z)/2)*nM.z; // угловые скорости демпфируются покомпонентно
    R = W*Ts;                    // здесь приращение собственно углов качки  КБ
  }
  //! переработка результатов динамического позиционирования и автоматическое
  //!     управление ходом и курсом корабля на штормовой волне
  //
  V = Tensor(*this)*V;            // переход на общую морскую систему координат
  V.rotZ( -Direct.z );            // в глобальных отсчета по носу, как к северу
  V.x -= cSp;                     // отклонение скорости идёт под демпфирование
  U = V; U &= V; U &= muF*Ts;     // кубический компонент нормируется th=[-1÷1]
  V &= nF;                        // линейная часть демпфирования малых сдвигов
  V &= (Vector){ 1.0,1-0.5*tanh( U.y ),1-0.5*tanh( U.z ) };
  V.x += cSp-dV.x;               // покомпонентное гашение изменённых скоростей
  Speed = V.x;                   // скорость хода в МБ для информационных нужд
  V.rotZ( Direct.z );            // обновление курса с коррекцией демпфирования
  V = V/Tensor(*this);           // возврат из МБ в КБ
  //
  // для изменчивого хода необходимо устраивать соревнование с тягой движителей
  // - или плавное управление ходом корабля с неким предопределенным ускорением
  // = по сути а-ля преодоление сопротивления пропорционально квадрату скорости
  {
    //!   управление курсом корабля с выбором относительно медленной циркуляции
    //            Ty=x*Zenit - азимут по правому траверзу в плоскости горизонта
   Real dR,dA;
   Vector Tr = Zenit*(x*Zenit);    // курс <= перпендикуляр от правого траверза
    dR = angle( Course,atan2( -Tr.y,Tr.x ) );     // все углы от -180° до +180°
    if( fabs( dR )<0.01*_dR )dCs=_Ph/360; else    // на курсе плавное удержание
    if( fabs( dR )>_Pi/32 && dCs<_Ph/90 )dCs=_Ph/60; // помалу на заданный курс
    dA=copysign( (ScanStatus()&ALT)?0.0:dCs*Ts,z.z );  // ограничитель скорости
    R.z-=( dR=minmax( -dA,dR,dA ) );
    if( Statum )
    { if( fabs(Direct.y+R.y)>_Ph*0.6 )R.y/=2;  // ограничение дифферента 54÷72°
      Rotate( R.y,dir( Zenit*(y*Zenit) ) );    //+ дифферент от вертикали в МБ
      Rotate( R.x,x );       //+ крен     в KB = строго на корабельной абсциссе
    } Rotate( R.z,Zenit );   //+ рыскание в МБ ~ отклонение курса при вертикали
    //
    //   что бы ни получили в проворотах, требуется корректура угловых отсчётов
    //       ~~ вынужденная проблема корректировки курсовых углов и углов качки
    //
    Tr = Zenit*(x*Zenit);  // курс = перпендикуляр в горизонте правого траверза
    Direct.z=atan2( Tr.y,Tr.x );  // корректировка систематической девиации
    if( Statum )                  // ~~ нет режима кинематического скольжения
    { Tr = Tr/Tensor(*this);      // тем же курсом к продольному дифференту  КБ
      Direct.y=atan2( Tr.z,Tr.x ); // по обратному отсчету по подъему горизонта
      Tr = Zenit/Tensor(*this);   // зенит во взгляде в корабельных координатах
      Direct.x=atan2( Tr.y,Tr.z ); // крен в заглублении отсчёта оси ординат КБ
    }
    // ежесекундная отметка навигационной информации на консоли(признак работы)
    //
   static Real Tz=0; // и посекундная выдача динамики хода на текстовую консоль
    if( Sea.Trun-Tz>1.0 ){ Tz=Sea.Trun; textcolor( LIGHTCYAN );
        print( 2,23," Курс( ∂ )заданный => %.1f°<%.1f> %.1f°    \n"
                    "           крен %3.1f°,  дифферент %3.1f°  \n"
                    "           Скорость %3.1f из %3.1f узлов   \n",
                   -Direct.z*_Rd,dR*_Rd,Course*_Rd,Direct.x*_Rd,Direct.y*_Rd,
                    Speed*3600/_Mile,cSp*3600/_Mile ),gotoxy( 2,22 );
  } }
  // дополнение скорости хода по текущему курсу, построение траектории движения
  //
  Whirl += W;        // угловые скорости изменения курса, крена и дифферента КБ
  Head += angle(Direct); // величины осевых углов Крылова-Эйлера(временно) в МБ
  Rate += V;        // поступательные скорости под действием архимедовых сил КБ
                   // всплытия, и градиентов давления под волновыми склонами КБ
//( U=Buoyancy ).z=0.0;  // выбор нового местоположения вдоль маршрута движения
/*vC = Gravity;         // уточнение к подводному центру бокового сопротивления
  if( iV>Volume*eps )   //   при условии, что часть корпуса погружена в воду...
  {       // аппликата погружения центра величины подводного объёма ниже центра
   Real dZ = (Tensor(*this)*vF).z - (Tensor(*this)*vB).z; // площади ватерлинии
    dV = ( vF*(iF*dZ) + vB*iV )/( iF*dZ+iV );       //!!? vF заглубляется до vB
//  dV = ( vF*iF + vB*iV )/( iF+iV );               // без объёма на ватерлинии
    R.x= tanh( muF.x ); U.x=1.0-R.x;                // получится центр величины
    R.y= tanh( muF.y ); U.y=1.0-R.y;
    R.z= tanh( muF.z ); U.z=1.0-R.z;                 // R*=iV; U*=iV; в долях
    vC = ( dV&R )+( vC&U );                          // в гиперболических долях
//  vC = (vC*Volume+iV*((dV&R)+(vC&U)))/(iV+Volume); // ~ со сглаживанием сбоев
  }
*/
//Route+=( Locate+=Matrix(*this)*( V *Ts ) );         // ~-~ без проворачивания
  Route+=( Locate+=Matrix(*this)*( ( V+vC*W )*Ts ) ); //+Matrix(*this)*Gravity;
  Z = Locate.z;   // ++ отклонение по аппликате от исходного центра масс     МБ
                  // центр корабельного базиса и собственно траектория хода  МБ
                  // вертикаль центра отсчета согласует осадку с водоизмещением
  Mix += (Vector){ Speed,Course,Sea.Value( out( Zero ) ) }; // - к протоколу
  return *this;
}
/* пока и так издревле повелось с тремя неверными углами Эйлера-Крылова
   (проблемы с большими углами поворотов, но в отладках приходилось мириться)
       axiY( angle( Direct.y ) ), -- дифферент
       rotX( angle( Direct.x ) ), ~~  +крен
       rotZ( angle( Direct.z ) ); ==  +рыскание

 static Real iVz=eps;  //  и величина водоизмещения при максимальном погружении
   if( iF>Floatage*eps && iV>Volume*eps )vD=( vF*iF*dZ + vB*iV )/( iF*dZ+iV ); ?
   if( iVz<iV )iVz=iV; // фиксируется величина водоизмещения полного погружения
   if( Statum>1 )vB.x=-vR.y/Volume;     // в парах сил какие-то погрешности С м
   if( iV>Volume )     // полное погружение в подводное положение
        vB/=iVz;       // положение центра величины в локальных координатах(!?)
   else vP=vB=Gravity; // центр величины <∨> сбрасывается в исходное положение

   vD = Gravity;
   if( Statum>1 )vD += ( vS*vR )/norm( vS ); else // исключено из гидромеханики
   if( Statum==1 ){ vD=vB; vD.z=Gravity.z; }      // движения и только рисуется


*/
