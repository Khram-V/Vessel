//
//   Здесь собраны все инициализации и собственно расчетные операции
//      по моделированию динамики корпуса на волнении
/*                                                          ©2024-11-20 ‏יְרוּשָׁלַיִם
  ==
  == геометрия корпуса, состояние движения и маршрутные записи курса и скорости
  ==
  Real Length,Breadth,Draught,    // конструктивные длина, ширина и осадка  [м]
       Course,dCs,  // курс корабля и обратное время для полуциркуляции п·dT/30
        Speed,cSp;  // настоящая и устанавливаемая скорость хода корабля  [м/с]
  Vector Locate;    // местоположение корабля для отсчётов волновых полей   [м]
  Flex Route,       // маршрут - траектория контролируемого хода корабля  МБ[м]
       Rate,        // скорости смещения корпуса в корабельном базисе   КБ[м/с]
       Head,Whirl,  // и вращательные движения корпуса в углах Крылова  [р,р/с]
       Mix;         // сохраняемые величины для повторных расчётов в протоколах
                    // Mix.z - уровень моря на миделе; у - курс; x - скорость..
  byte Statum;  //   0 - кинематическое позиционирование со скольжением корпуса
                //       над волнением по хордам четырёх точек склона, иначе:
                //   1 - объёмное гравитационное всплытие: борт-киль-вертикаль
                //   2 - гидростатическое давление в волне на смоченной обшивке
                //   3 ÷ ≈ вихреисточники обтекания корпуса набегающим потоком
                //   4 - компоненты скорости на обшивке под волновыми гребнями
                //  ~~ ~ полные потоки в механике отражения волн(в перспективе)
                //  ++ ~ обтекание корпуса с трохоидальными волнами по глубине
                //  ~~ - динамическое изменение тензора инерции и центра масс
                //  ~~ - перепады давления по градиентам поверхности ватерлинии
  unsigned Educt; // = управление выводами результатов мореходного эксперимента
                // 1 - ходкость и отклонение от заданной скорости хода
                // 2 - направление движения и наибольшее рыскание на курсе
                // 4-8-16 - экстремумы вертикальной, бортовой и килевой качки
                // 32-64-128 -вертикальные ускорения на корме, миделе и по носу
                // 512 - 0х200 - признак необходимости записи только превышений
  byte DrawMode; --  0 - ватерлиния строится при любом графическом раскладе
                     1 - прорисовываются только собственно штевни и шпангоуты
                     2 - оставляется подводная часть со шпангоутами над водой
                     3 - весь корпус прорисовывается целиком отчасти прозрачным
                   х04 - тоже, без обшивки и только с триангуляционными ребрами
   ++              х08 - исходный вариант: одно поле графиков и картушка справа
   -- размерения и динамические параметры корпуса корабля (Volume=0-обновление)
   -- локальная корабельная система координат определяется в составе структуры
   -- Hull::Base и включает координаты пространственного местоположения
   -- Point{X,Y,Z} и тензор тривекторов поворотов Matrix::Vector{x,y,z}
  Real hX,// поперечная метацентрическая высота задаёт аппликату центра тяжести
      Volume,  iV, // исходное водоизмещение, мгновенный погруженный объем V м³
      Surface, iS, // подводная и смоченная поверхность корпуса            S м²
      Floatage,iF, // исходная и действующая площадь ватерлинии            F м²
      sT,          // интервал времени для графиков с кинематикой XYZ-качки сек
      Trim,        // дифферент задается простым смещением центра величины[рад]
      Kv;          // доля сброса отрицательного давления в парадоксе Даламбера
  Vector Ofs,      // внутренние смещения отсчетов по миделю и ватерлинии {x,z}
      Gravity,     // + центр тяжести в локальных корабельных координатах    G
      Buoyancy,  vB, // координаты центра величины,центра объема корпуса     cB
      Floatable, vF, // центр площади исходной и действующей ватерлинии      cF
      Metacenter,vM, // начальный + текущий поперечные метацентры    в КБ Zm(x)
                 vW, // нормаль интегро-осредненной площади ватерлинии      (δ)
                 vD, // условный центр сосредоточения гидродинамических пар-сил
                 vC, // динамический центр пространственного движения корпуса
                 vS, // накопительный вектор сил от перепада уровня моря  [H/ρ]
                 vR; // поворотный момент от криво-наклонной ватерлинии   [Н·м]
                     // с оценкой мгновенной метацентрической высоты в МБ! h(z)
  Matrix inWater,mW, // моменты инерции площади действующей ватерлинии     I м⁴
         inMass; //,mM; моменты инерции исходного и смещенного корпуса     G м⁴
  Vector nF,nM, // относительные коэффициенты угловых и поступательных движений
       muF,muM; // обобщённые параметры демпфирования - задаваемые извне
                   -- демпфирование (>0) до исключения(=1) скорости качки
      // под большими углами крена и до опрокидывания сопротивление утраивается
*/
#include "Aurora.h"  // объекты и производные операции с корпусом на волнении
                     //   ++ дополнения графической среды OpenGL->Window-Place
                     //  Hull: координатные оси корабельного базиса морской СК
static Vector        //! КБ - локальный корабельный базис; МБ - морской базис
       vBi,          //  положение центра величины из предыдущего шага времени
       Vship,        //  вектор полной скорости хода, качки и дрейфа       в КБ
       Wship,        //  и мгновенная угловая скорости движения корабля      КБ
       Vwave,Wwave,  //  потоковые скорости захватываемого волной корабля    МБ /*@*/
             Mwave,  //  контрольная скорость расчётов потокового вращения   МБ
                dV;  // срединная точка к центрам величины и площади ватерлинии
//              vD,  // условный центр сосредоточения гидродинамических пар-сил
//
//     При пересчёте базисов учитывается только вертикальная качка, пока ...
//
Vector Hull::out( Vector a ) const { ( a=LtA( a ) ).z+=Locate.z; return a; }
Vector Hull::in( Vector A ) const { A.z-=Locate.z; return AtL( A ); }

void
Hull::ThreeInitial()  // начальная очистка всех величин динамических параметров
{
  if( !KtE )          // если самое первое обращение - вместо конструктора Hull
  { Volume=Surface=Floatage=0;
    Vship=Wship=Mwave=Gravity=vBi=vC=dV=Zero; inWater=0.0; inMass=0.0;
  } else
  { Vship=AtL( (Route[-1]-Route[-2] )/Ts ); //Tensor(*this); ~~ старые варианты
//{ Vship=(Rate[-1]+Rate[-2]*2)/3;    // усредняемая скорость хода и вращения
//{ Vship=Rate[-1];                   // скорость хода и вращения
    Wship=Whirl[-1];   //  в пространстве, сведённое к локальным проекциям в КБ
    if( Statum>3 && Storm->Exp.wave )   // скорость течения под волной в центре
    { Storm->WaveV( Trun,out( vB ),Mwave );               // величины для    МБ
      Mwave=AtL( Mwave );        //=Mwave/Tensor( *this ) // осевого потока  КБ
  } }
  vBi=vB; // vD=vC;   // гидродинамические центры предыдущего расчётного такта
  iV=iS=iF=0.0;       // скалярные собраны в кучу, векторные - все производные
  mW=0.0; //mM=0.0;   // тензорные объекты в том же ранге срочных перерасчетов
  vW=Zenit;           // нормаль интегро-осредненной площади ватерлинии     (δ)
  vB=vP=vF=Zero;      // сумматоры для задействования ранее вычисленных величин
  Vwave=Wwave=Zero;   // осредняемые скорости потоков и разворотов в толще воды
  vM=vS=vR=Zero;      // метацентр, силы и моменты от перепадов уровней у борта
}
void Hull::Three( int Level,  // -2-днище; -1-вода; 0-в-линия; 1-воздух; 2-борт
 _Vector a,_Vector b,_Vector c )    //! динамический перерасчет параметров
{ if( Level<=0 )                    //  борт, общекорабельная архитектура мимо
  { Vector A=out( a ),B=out( b ),C=out( c );
   Real aw=Storm->Value( A ),bw=Storm->Value( B ),cw=Storm->Value( C );
   Field &Sea=*Storm;
   Vector S =( (a-c)*(b-c) )/2.0;   // нормаль площади элемента обшивки    в КБ
   Real   W =abs( S );              // площадь малого треугольника на обшивке
    if( W<eps )return;              // -- сброс обнулённого фрагмента
    Vector L =( a + b + c )/3.0,    // центр площади к треугольнику обшивки  КБ
           M = 0.75 * L,            // центр объема элементарного тетраэдра  КБ
           Sz=( A-C )*( B-C )/2;    // ориентация в МБ
      //   Sz=( (Point(a)-Point(c))*(Point(b)-Point(c)) )/2; // ориентация в МБ
    Real   V =( c % S )/3.0;        // водоизмещение элементарного тетраэдра
           iV += V;                 // суммирование тетраэдров водоизмещения
           vB += V*M;               // векторная сборка статических моментов КB
    if( !KtE )                      // моменты инерции объема/массы корпуса
    { Matrix J={{0},0};             // временно из общей механики исключается
      J.x.x = ( a.y*a.y+b.y*b.y+c.y*c.y + a.z*a.z+b.z*b.z+c.z*c.z
              + a.y*b.y+a.y*c.y+b.y*c.y + a.z*b.z+a.z*c.z+b.z*c.z )*V/10.0;
      J.y.y = ( a.x*a.x+b.x*b.x+c.x*c.x + a.z*a.z+b.z*b.z+c.z*c.z
              + a.x*b.x+a.x*c.x+b.x*c.x + a.z*b.z+a.z*c.z+b.z*c.z )*V/10.0;
      J.z.z = ( a.x*a.x+b.x*b.x+c.x*c.x + a.y*a.y+b.y*b.y+c.y*c.y
              + a.x*b.x+a.x*c.x+b.x*c.x + a.y*b.y+a.y*c.y+b.y*c.y )*V/10.0;
      J.x.y=J.y.x =(-0.5*( a.x*b.y+a.x*c.y+b.x*c.y + a.y*b.x+a.y*c.x+b.y*c.x )
                         - a.x*a.y - b.x*b.y - c.x*c.y )*V/10.0;
      J.x.z=J.z.x =(-0.5*( a.x*b.z+a.x*c.z+b.x*c.z + a.z*b.x+a.z*c.x+b.z*c.x )
                         - a.x*a.z - b.x*b.z - c.x*c.z )*V/10.0;
      J.y.z=J.z.y =(-0.5*( a.y*b.z+a.y*c.z+b.y*c.z + a.z*b.y+a.z*c.y+b.z*c.y )
                         - a.y*a.z - b.y*b.z - c.y*c.z )*V/10.0;
      inMass += J;
//      ( inMass += ( J *= 0.1*V ) );
    }
    if( Level<0 )     //! гидростатика с гидродинамикой обводов ниже ватерлинии
    { iS += W;        // + скаляр площади смоченной поверхности судовой обшивки
      if( Statum>1 ){ // если внешнее давление на треугольники и пары сил  в КБ
       Vector Cz=L;   // здесь будет местоположение точки действия сил давления
       Vector R=out(L); // центр элементарного треугольника в морском базисе МБ
       Real Hz=R.z;                 // подводная вертикаль центра давления в МБ
        if( KtE )Hz -= Sea.Value( R );    // добавка к высоте по уровню моря МБ
        if( Hz<-eps && W>eps )   // подводный пересчёт по вертикали центра силы
        { Vector Z=Zenit*( Sz/W );  // длина к синусу угла вертикали с нормалью
          if( norm( Z )>eps )       // и если треугольник не горизонтален
          { Real az=A.z-aw, bz=B.z-bw, cz=C.z-cw,     // погружение вершин в МБ
            d=( az*(az-bz-cz)/2 + (bz*bz+bz*cz+cz*cz)/6 - sqr( az-Hz ) )/Hz;
            Z=(d/abs( Z ))*( dir( Z*Sz ) );  // к центру действия силы давления
            Cz=in( R-Z );                   // возврат в корабельные координаты
        } }         // гидростатика всегда есть в интегралах по судовым обводам
        vS += Hz*S; //  накопительный вектор сил давления треугольников [Н/ρ]КБ
        vR += Hz*( (Cz-Gravity)*S );  //++ пара сил от центра тяжести [Н·м/ρ]KБ
        if( Statum==2 )vP -= Hz*W*Cz; //... к центру действия сил давления воды   { -= }
        //
        //   Здесь гидростатика дополняется компонентами скоростных потоков для
        //           для взаимовлияния хода, качки и всех штормовых воздействий
        if( KtE )
        if( Statum>2 ){    // ходовый+волновой, встречный набегающий поток воды
         Vector w= Zero,   //~~ правила знаков ?? всё необходимо заново сверять
                s= S/W,    //  ориентация нормали треугольника в корабельной СК
                v= Vship   // *(1+Breadth/Length/2) - для шара получится 1,5 КБ
                 + Wship*(L-Gravity); // скорость треугольника, правило знаков?   { + }
          if( Statum>3 && Sea.Exp.wave )      // подводные волновые воздействия
          {             // выборка скорости течения под волной по координатам R
            Sea.WaveV( Trun,R,w );     // скорость потока в волне          [МБ]
           Vector u = w;               // копия для потокового интеграла   [МБ]
            w = AtL( w );              // скорость частицы воды на обшивке [КБ]
            v -= w;                    // для зеркального отражения/скольжения
            if( lFlow )      // к усреднению потока воды на поверхности обшивки
            { u.z=0; u = AtL( u ); // потоковое увлечение по горизонту
              Vwave += V*u;  // по всем э лементам объёма(водоизмещения) корпуса
             Real rW=norm(L-vBi); // полагая слабое влияние особо близких точек
              if( rW>eps )Wwave += ( V/rW )*( (u-Mwave)*(L-vBi) ); // по объёму  { += }
          } }
         Real nv=s%v;       // нормальная компонента отражаемых корпусом частиц
          if( nv<0 )        // на воде отрицательное давление реализуется плохо
          if( Kv<1.0 )nv*=( 1+(1-Kv)*(s%dir(v)) ); // сброс парадокса Даламбера
          Hz=( norm( s*v )   // касательная компонента набегающего потока воды   { s*v }
             + norm( s*w )   // удвоение скользящей компоненты отражаемой волны  { + }
             - norm( v )     // интегральная скорость потока = по ходу корабля   ( - }
             - copysign( nv*nv,nv ) )/(_g*2.0); // импульс c непротеканием в КБ  { - }
          vS += Hz*S;   // накопительный вектор сил давления треугольников в КБ
          vR += Hz*( (L-Gravity)*S );    // ++ моменты от исходного центра масс
          vP -= (Hz*W)*L;                // к центру действия сил давления воды  { -= }
        }
      }
    } else        //!  теперь всё это относится к уровню действующей ватерлинии
    { Real        // -- первые две вершины по одному борту, третья - по другому
      s=Sz%Zenit; // площадь элемента ватерлинии в горизонтальном проецировании
      iF += s;    // площадь действующей ватерлинии инвариантна в любом базисе
      vF += s*L;  // момент для вычисления центра площади ватерлинии{x4/3} в КБ
      vW += Sz;   // ещё один векторный элемент интегральной площади ватерлинии
      //    обоснованность задействования перепадов давления на противоположных
      //   бортах не сильно велика, но по эффекту не особо действенна и пагубна
      if( Statum==1 ) //! силы и моменты по уровням на треугольниках ватерлинии
      { Vector F; // элемент силы в глобальной морской системе координат - в МБ
        F = 0.5*( 0.5*( aw+bw )-cw )*Sz/W;                 // правило знаков !!
        F.z=0.0;           //-- или горизонтальный компонент дрейфовых сил в MB
        F = AtL( F );      // g -- величина силы-ускорения вместе с реакцией КБ
        vS+=F;             // величина горизонтальной сдвиговой силы в КБ [Н/ρ]
        vR+=(L-Gravity)*F; // разворачивающий момент дрейфа на склоне волн[Н·м]
      }
#if 0
     Real ar=hypot( a.y,a.z ),            // + простая дистанция от оси абсцисс
          br=hypot( b.y,b.z );            // момента инерции площади ватерлинии
      W = fabs( a.x*br-b.x*ar )/12.0;     // иная площадь элементарной площадки
      mW.x.y=                             // моменты инерции площади ватерлинии
      mW.y.x+=( a.x*br/2 + a.x*ar + b.x*br + b.x*ar/2 )*W;     // упорядоченные
      mW.x.x+=(  ar*ar  +  ar*br  +  br*br  )*W;               // фрагменты
      mW.y.y+=( a.x*a.x + a.x*b.x + b.x*b.x )*W;               // ватерлинии
#else
      s /= 6.0; // W/6.0;                 // иная площадь элементарной площадки
      mW.x.y=                             // моменты инерции площади ватерлинии
      mW.y.x+=s*( a.x*b.y/2 + a.x*a.y + b.x*b.y + b.x*a.y/2 ); // упорядоченные
      mW.x.x+=s*( a.y*a.y + a.y*b.y + b.y*b.y );               // фрагменты
      mW.y.y+=s*( a.x*a.x + a.x*b.x + b.x*b.x );               // ватерлинии
#endif
    }
  }
}
//!  рассматривается динамика корпуса корабля с переменным водоизмещением и
//!  деформируемыми моментами инерции в условиях интенсивного морского волнения
//
void           // метацентрическая высота hX определяется в исходных данных [м]
Hull::ThreeFixed() // постобработка всех треугольников, фиксация первой статики
{                //  корпус может погрузиться iF==0 или выскочить из воды iV==0
               // метацентрические расчеты опасны делениями на площади и объёмы
 Field &Sea=*Storm;
 bool isWaterPlane=iF>Floatage/32,   // существование действующей ватерлинии
      isDisplacement=iV>Volume/64;   // потеря поверхности воды после взлёта
  if( isWaterPlane )                // если нет площади действующей ватерлинии
  { vF /= iF;      // условный центр площади ватерлинии по горизонту, тоже в КБ
    vW = dir( vW ); // интегральная нормаль к площади действующей ватерлинии КБ
    mW = Steiner( mW,vF );  // моменты инерции исходной площади ватерлинии I м⁴
  } else
  { if( !KtE )Break( "Ошибка инициализации\n\t(нет ватерлинии)" );
    vW=Zenit;        // направление вектора всплытия вертикально вверх
    vF=Floatable;    // взамен нуля возврат исходного центра площади ватерлинии
    vM=Metacenter;   // метацентра нет, и пусть также на начальной остойчивости
    mW=inWater;      // может быть нулём или центром базиса по определению
//  if( !isDisplacement )Mwave=vC=vP=vB=Gravity;     // сам по себе над волнами
  }
  if( isDisplacement )  // судно в водоизмещающем положении на поверхности моря
  { vB /= iV;      // корабельные координаты центра величины(подводного объема)
    Vwave/=iV*2;  //! в волновом потоке участвует объем элементарного тетраэдра
    Wwave/=iV*_Pi; // с осреднением поступательного и вращательного движений КБ
    Wwave.x/=24;   // верно полагать проскальзывание кренящих потоков(на сколь)
    //
    // !..не приводим моменты инерции к центру масс и центру площади ватерлинии
    //                      // всё в исходной корабельной системе координат ...
//  vP /= 2.0;    // ... что-то там то ли непонятно, то ли не совсем "чисто"...
    if( Statum<=1 )vP=vB; else
    if( Statum==2 )vP/=abs(vS)*2;  // сразу весь вектор сил давления на обшивке
    else vP=vB+vP/iV/2;// или гидродинамическая поправка по Бернулли-Торричелли
    //
    //    Здесь уместно выставить динамический центр движения корпуса при качке
    //
    vC = (Volume*Gravity + iV*vP )/( Volume+iV );  // что если без премудростей
  } else
  { if( !KtE )Break( "Ошибка инициализации\n\t(нет водоизмещения)" );
    Vwave=Wwave=vS=vR=Zero;// летучий голландец в свободном от поддержки полёте
    Mwave=vB=vC=vP=Gravity; // сам по себе над волнами
  }

  if( !KtE )       //! фиксация начальных гидростатических характеристик   в КБ
  { Volume=iV;     // исходное водоизмещение, мгновенный погруженный объем V м³
    Surface=iS;    // подводная и смоченная поверхность корпуса            S м²
    Floatage=iF;   // исходная и действующая площадь ватерлинии            F м²
    Buoyancy=vB;   // координаты центра величины,центра объема корпуса    cB м
    Gravity=vB;    // центр тяжести в локальных корабельных координатах    G м
    vM.z=hX;       // в первом вхождении метацентрическая высота задается явно
    vM.x=vB.z+mW.x.x/Volume;               // аппликата поперечного метацентра
    vM.y=vB.z+mW.y.y/Volume;               // продольного метацентра, дифферент
    Metacenter=vM; // аппликаты теоретических и текущих метацентров   Zm,ZM,h м
    Gravity.z=vM.x-hX; // аппликата центра масс встанет ниже метацентра   hX м
    Floatable=vF;  // центр площади исходной и действующей ватерлинии      cF м
    inWater=mW;    // моменты инерции исходной площади ватерлинии          I м⁴
    inMass=Steiner( inMass,vB,Gravity ); // + инерции массы/объема корпуса G м⁵
    KtE=1;                              // = переходит сначала на ЦВ затем к ЦТ
    Head[0].z=-Course;// углы геометрические, курс навигационно-географический
    Mix[0].z=Sea.Value( out( Zero ) ); Mix[0].y=Course; DampInit();
  } else //! KtE≠0 предотвращает повторы вычислений начальных данных по корпусу
  { Vector A=out( vB ),                 // Во внешней морской системе координат
           B=out( Gravity );            // действующих центров по полной массе
    vM.x = A.z + mW.x.x/Volume;         // аппликата поперечного метацентра
    vM.y = A.z + mW.y.y/Volume;         // продольного метацентра, дифферент
    vM.z = vM.x-B.z;       // hX(z) мгновенное значение метацентрической высоты
} }
//!    динамика корпуса под действием внешних сил и моментов волновой природы
//        ~~ здесь вычислительный шаг во времени задаются по куранту для самых
//           быстрых волн, и еще предстоит это поправить на динамику корабля
//!    оси угловой качки сводятся к центру тяжести с аппликатой мгновенного
//     центра величины (погруженного объёма) в корабельной системе координат
//     (иначе неадекватные скорости течений вблизи обшивки)
//
Hull& Hull::Movement() // шаг во времени Ts устанавливается в Field::Simulation
{ Vector
    Direct=Head[-1], // отсчёты действующих углов x-крен y-дифферент z-рыскание
    A,B,C,D,E,       // крестовой шаблон на взволнованной поверхности моря
    R,U; //,dV=Zero; // действующий градиент наклона волновой поверхности
  Field &Sea=*Storm;
  //
  //  быстрый градиент волнового склона по кресту четырех противоположных точек
  //
  if( Statum<2 )  // скользящая кинематика по направлению действия объемных сил
  { A = Sea.Locas( out( Zero ) );            // пять точек в корабельном базисе
    B = Sea.Locas( out((Vector){Length/3}))-A;    // градиент инвариантен любым
    C = Sea.Locas( out((Vector){Length/-3}))-A;      // ориентациям ортогоналей
    D = Sea.Locas( R=A+(E=((Breadth/Length/2)*(C-B))*Zenit) )-A;
    E = Sea.Locas( R=A-E )-A;
    R = A+(B+C+D+E)/5.0;              // == у всех треугольников одинаковый вес
    U = rolZ( -Direct.z ).            // c выбором направления по курсу корабля
        AtL( dir( B*D+D*C+C*E+E*B ) );// усреднённый вектор в морском базисе МБ
  }
  if( !Statum )   //! свободно-жесткий вариант (°) лагом/вразрез/носом на волну
  { // простое статическое касание поверхности склонов волн половинных размеров
    //+ реализовано гравитационно-инерционное скольжение по склонам волн
    //  затем вычисляются аппликаты волн по неким габаритным размерам корпуса
    // U = vW * rolZ( -Direct.z );          // к случаю интегрального градиента
        // после смены курса определяем местоположение оконечностей (без качки)
    A = B - C;                       // плечо на линии фиксации скорости потока
    Sea.WaveV( Trun,B,B );           // скорость потока в носовой оконечности
    Sea.WaveV( Trun,C,C );           // скорость потока в кормовой оконечности
    Direct.z +=(A*(B-C)).z*Ts/norm( A ); // скорости к плечу = угловая скорость
    Direct.y = atan2(  U.x,U.z );  // уточняющий перерасчёт для угла дифферента
    Direct.x = atan2( -U.y,U.z );  // подборка нового фиксированного угла крена
      axiZ( Direct.z );            // рыскание: в три угла: курс-дифферент-крен
    Rotate( Direct.y,y );          // +дифферент: приведение положения корпуса
    Rotate( Direct.x,x );          // +крен: на условно больших углах поворотов
    Vship.x += Direct.y * _g*Ts;   // ускорение и скорость скользящего движения
    Vship.y -= Direct.x * _g*Ts/2; //             по градиенту волнового склона
    Vship.z = ( R.z-Locate.z )/Ts; // скорость по вертикальной качке
    Locate.z = R.z;                // изменение аппликаты посадки на миделе КВЛ
    Wship=angle(Direct-Head[-1])/Ts; // скорость изменения курса и углов качки
    R = 0; //Tensor(*this)*(W*Ts);   // чтоб без дополнений в динамике качки MБ
    dV= Zero;
  }
  //  изначально эксперимент строился только на главных компонентах архимедовых
  //  сил всплытия по вертикали, как бортовая, килевая и вертикальная качка/нет
  //   и все другие варианты объёмной гидро(статической)динамической постановки
  //                          корпуса корабля на морскую волну большой крутизны
  else
  { Vector B=vS; // суммарное действие всех сил давления у смоченной обшивки КБ
    //
    //      вычисления соотносятся с гравитационным центом тяжести и мгновенным
    //  или действующим центром величины, при этом внешние силы определяются во
    //  внешней морской системе координат, в то время как реакция  и приращения
    //  скоростей в локальном корабельном базисе (как-то так видится с мостика)
    //                   корабельная система координат (КБ) - корабельный базис
    //
    //                           гравитационная разность чисто по водоизмещению
    if( Statum==1 )B += AtL( ( iV*vW.z )*vW );              // с переходом в КБ   { += }
    //
    //       объёмные или поверхностные силы Архимедового всплытия без ρ/ρ в КБ
    //                        водоизмещение - гравитационная сила массы корпуса
    //
    dV = B/Volume - AtL( Zenit );      // нормированное к единице ускорение
//! if( norm( dV )>4.0 )dV=dir( dV );  // максимум ускорения свободного падения
    Vship += ( dV *= _g*Ts ); // приращение скоростей поступательной качки [КБ]
    //
    //! бортовая, килевая качка и рыскание - дрейф: F=ρ∙g∙h∙S/2; a=F/V; dV=a∙dt
    // здесь центры масс и величины отмеряются относительно исходной ватерлинии
    //  плечо центра тяжести относительно мгновенно-переменного центра величины
    //
    R = vB-Gravity;     // большое плечо для момента архимедового всплытия в КБ
    //
    // Волновые воздействия задаются архимедовыми силами всплытия по градиентам
    //    поверхностей равных давлений, и с величиной погруженной части корпуса
    // Вектор сил тяжести, проходящий через динамический центр,
    //    не создает никаких кренящих моментов
    //
    //!  ~~ если корпус выходит из воды, то волновое воздействие прекращается
    //   установка внешней гидростатики в местной корабельной системы координат
    //
    if( Statum==1 )
      B = _g*( R*B    // ω=ε·t  большие архимедовы моменты в корабельном базисе
        + vS*( Gravity-vF ) ); // ?  момент вращений от дрейфовых сдвигов на ВЛ
    else                       // ?  здесь или центр тяжести или центр величины
      B=_g*vR;                 // свободная качка и рыскание на склонах волн /ρ
    //
    // боковые смещения полностью гасятся моментом простого крена на циркуляции
    // таким образом пусть любое ускорение центра масс образует момент пары сил
    //  !!!    относительно действующего центра величины (не от ЦБС или осадки)
    //                                      и плечо в морскую систему отсчётов
    if( Route.len>3 )
        B += (Volume/Ts) * ( R*( AtL( angle( Head[-1]-Head[-2] ) ) * Vship ) ); //! /2; /!?
//!     B -= (Volume/Ts/Ts)*(R*( AtL(Route[-1]-2.0*Route[-2]+Route[-3] ) ) );     // { += }
    //
    //  Моменты в ускорения поворотов -> скорости вращения -> угловые положения
    //
    Wship+=Ts*(B/Matrix(inMass));//угловые дифференциалы приращения поворотов/ρ
                            // суммирование скоростей крена.дифферента.рыскания
    { Real w=max( fabs( Wship.x ),max( fabs( Wship.y ),fabs( Wship.z ) ) );
      if( w>_Pi/6.0 )Wship*=_Pi/w/6.0; //_Pd/6 полный оборот≈6сек оверкиль≈3сек
    }
    U=Wship; U&=Wship; U&=Ts*muM; // большие скорости ослабляются степенью куба
    Wship.x*=(1-tanh(U.x)/2)*nM.x*(1-sqr(Direct.x*0.5625/_Pi)); // учетверённое
    Wship.y*=(1-tanh(U.y)/2)*nM.y;// подторма́живание при оверкиле, затем другие
    Wship.z*=(1-tanh(U.z)/2)*nM.z;//угловые скорости демпфируются покомпонентно
    R = Ts*Wship;                 // здесь приращение собственно углов качки КБ
  }
  //! переработка результатов динамического позиционирования и автоматическое
  //!     управление ходом и курсом корабля на штормовой волне
  //
  Vship = LtA( Vship );           // переход на общую морскую систему координат
  Vship.rotZ( -Direct.z );        // в глобальных отсчета по носу, как к северу
  Vship.x -= cSp;                 // отклонение скорости идёт под демпфирование
  U=Vship; U&=Vship; U&=Ts*muF;   // кубический компонент нормируется th=[-1÷1]
  Vship &= nF;                    // линейная часть демпфирования малых сдвигов
  Vship &= (Vector){ 1.0,1-0.5*tanh( U.y ),1-0.5*tanh( U.z ) };
  Vship.x += cSp-dV.x;           // покомпонентное гашение изменённых скоростей
  Speed = Vship.x;               // скорость хода в МБ для информационных нужд
  Vship.rotZ( Direct.z );        // обновление курса с коррекцией демпфирования
  Vship = AtL( Vship );          // возврат из МБ в КБ
  //
  // для изменчивого хода необходимо устраивать соревнование с тягой движителей
  // - или плавное управление ходом корабля с неким предопределенным ускорением
  // = по сути а-ля преодоление сопротивления пропорционально квадрату скорости
  {
    //!   управление курсом корабля с выбором относительно медленной циркуляции
    //            Ty=x*Zenit - азимут по правому траверзу в плоскости горизонта
   Real dR,dA;
   Vector Tr = Zenit*(x*Zenit);    // курс <= перпендикуляр от правого траверза
    dR = angle( Course,atan2( -Tr.y,Tr.x ) );     // все углы от -180° до +180°
    if( fabs( dR )<0.01*_dR )dCs=_Ph/360; else    // на курсе плавное удержание
    if( fabs( dR )>_Pi/32 && dCs<_Ph/90 )dCs=_Ph/60; // помалу на заданный курс
    dA=copysign( (ScanStatus()&ALT)?0.0:dCs*Ts,z.z );  // ограничитель скорости
    R.z-=( dR=minmax( -dA,dR,dA ) );
    if( Statum )
/**/{//if( fabs(Direct.y+R.y)>_Ph*0.75 )R.y/=2; // ослабление дифферента ~67,5°
      Rotate( R.y,dir( Zenit*(y*Zenit) ) );    //+ дифферент от вертикали в МБ
      Rotate( R.x,x );       //+ крен     в KB = строго на корабельной абсциссе
    } Rotate( R.z,Zenit );   //+ рыскание в МБ ~ отклонение курса при вертикали
    //
    //   что бы ни получили в проворотах, требуется корректура угловых отсчётов
    //       ~~ вынужденная проблема корректировки курсовых углов и углов качки
    //
    Tr = Zenit*(x*Zenit);  // курс = перпендикуляр в горизонте правого траверза
    Direct.z=atan2( Tr.y,Tr.x );   // корректировка систематической девиации
    if( Statum )                   // ~~ нет режима кинематического скольжения
    { Tr = AtL( Tr );              // тем же курсом к продольному дифференту КБ
      Direct.y=atan2( Tr.z,Tr.x ); // по обратному отсчету по подъему горизонта
      Tr = AtL( Zenit );           // зенит во взгляде в корабельных координатах
      Direct.x=atan2( Tr.y,Tr.z ); // крен в заглублении отсчёта оси ординат КБ
    }
 ///if( fabs( Direct.y )>_Ph*0.5 )Direct.y=copysign( _Ph*0.5,Direct.y );

    // ежесекундная отметка навигационной информации на консоли(признак работы)
    //
   static Real Tz=0; // и посекундная выдача динамики хода на текстовую консоль
    if( Trun-Tz>1.0 )
    { Tz=Trun; textcolor( LIGHTCYAN );
      print( 2,23," Курс( ∂ )заданный => %.1f°<%.1f> %.1f°    \n"
                  "           крен %3.1f°,  дифферент %3.1f°  \n"
                  "           Скорость %3.1f из %3.1f узлов   \n",
                 -Direct.z*_Rd,dR*_Rd,Course*_Rd,Direct.x*_Rd,Direct.y*_Rd,
                  Speed*3600/_Mile,cSp*3600/_Mile ),gotoxy( 2,22 );
    }
  }
  // дополнение скорости хода по текущему курсу, построение траектории движения
  //
  Whirl+= Wship;     // угловые скорости изменения курса, крена и дифферента КБ
  Head += angle(Direct); // величины осевых углов Крылова-Эйлера(временно) в МБ
//Wwave=Zero;                     ??? ~~~ vC или vP ~~~

vC=(vC+Gravity)/2;

  Route+=( Locate += Ts*LtA( R=Vship+vC*( Wwave+Wship )+Vwave ) ); //+Matrix(*this)*Gravity;
                   // ++ отклонение по аппликате от исходного центра масс    МБ
                   // центр корабельного базиса и собственно траектория хода МБ
                   // вертикаль центра отсчёта согласно осадке по водоизмещению
  Rate += R;       // поступательные скорости под действием архимедовых сил  КБ
//Rate += Vship;   // всплытия, и градиентов давления под волновыми склонами КБ
  Mix += (Vector){ Speed,Course,Sea.Value( out( Zero ) ) };  // - для протокола
  return *this;
}

/* пока и так издревле повелось с тремя неверными углами Эйлера-Крылова
   (проблемы с большими углами поворотов, но в отладках приходилось мириться)
       axiY( angle( Direct.y ) ), -- дифферент
       rotX( angle( Direct.x ) ), ~~  +крен
       rotZ( angle( Direct.z ) ); ==  +рыскание
*/
