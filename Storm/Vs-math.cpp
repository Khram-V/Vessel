//
//   Здесь собраны все инициализации и собственно расчетные операции
//      по моделированию динамики корпуса на волнении
/*                                                          ©2020-11-21 ‏יְרוּשָׁלַיִם
  ==
  == геометрия корпуса, состояние движения и маршрутные записи курса и скорости
  ==
 Real Length,Breadth,Draught,     -- конструктивные длина, ширина и осадка  [м]
      Course,dCs,   -- курс корабля и обратное время для полуциркуляции п·dT/30
      Speed, cSp;   -- настоящая и устанавливаемая скорость хода корабля  [м/с]
 Vector Locate;     -- местоположение корабля для отсчётов волновых полей   [м]
 Flex Route,        -- маршрут - траектория контролируемого хода корабля    [м]
      Rate,         -- скорости смещения корпуса в корабельном базисе     [м/с]
      Swing,Whirl;  -- и вращательных движения корпуса в углах Крылова  [р,р/с]
 byte Statum;   --   0 - жесткое кинематическое позиционирование корпуса над
                --       волнением по хордам на четырёх точках, иначе:
                --   1 - объёмное гравитационное всплытие: борт-киль-вертикаль
                --   2 - гидростатическое давление по смоченной обшивке в волне
                --   3 - касательная компонента скорости под волновыми гребнями
                --   4 -  и вихреисточники обтекания корпуса набегающим потоком
                --  ~~ ~ полные потоки в механике отражения волн(в перспективе)
                --  ++ ~ обтекание корпуса с трохоидальными волнами по глубине
                --  ~~ - динамическое изменение тензора инерции и центра масс
                --  ~~ - перепады давления по градиентам поверхности ватерлинии
 byte DrawMode;     --   0 - ватерлиния строится при любом раскладе
                    --   1 - только собственно штевни и шпангоуты
                    --   2 - подводная часть со шпангоутами над водой
                    --   3 - весь корпус прорисовывается целиком
                    -- х04 - тоже, но только с триангуляционными ребрами
                    -- х10 - разблокировка графики и включение надводного борта
   -- размерения и динамические параметры корпуса корабля (Volume=0-обновление)
   -- локальная корабельная система координат определяется в составе структуры
   -- Hull::Base и включает координаты пространственного местоположения
   -- Point{X,Y,Z} и тензор тривекторов поворотов Matrix::Vector{x,y,z}
   --
 Real hX, // поперечная метацентрическая высота задаёт аппликату центра тяжести
      Volume,  iV, -- исходное водоизмещение, мгновенный погруженный объем V м³
      Surface, iS, -- подводная и смоченная поверхность корпуса            S м²
      Floatage,iF, -- исходная и действующая площадь ватерлинии            F м²
  //  SecInert,iX, -- ==>inWater -=- момент инерции площади ватерлинии     I м⁴
      sT;          -- интервал времени для графиков кинематики XYZ-качки    сек
 Vector Gravity,       -- центр тяжести в локальных корабельных координатах  G
        Buoyancy,  vB, -- координаты центра величины,центра объема корпуса   cB
        Floatable, vF, -- центр площади исходной и действующей ватерлинии    cF
                   vW, -- нормаль к интегрированной площади ватерлинии      (δ)
                   vS, -- накопительный вектор сил от перепадов уровней   [H/ρ]
                   vR, -- вращательный момент искривленно-наклонной ватерлинии
  //               vW, -- проекции на вертикальные плоскости &Waterside      м²
  //               vP, -- центры горизонтальных давлений по дрейфу и ускорению
        Metacenter,vM, -- аппликаты исходного+текущего метацентров  Zm(x),ZM(y)
                       --  ++ мгновенная величина метацентрической высоты  h(z)
        DampF, DampM;  -- демпфирование (>0) до исключения(=1) скорости качки
 Matrix inWater,mW, -- моменты инерции площади действующей ватерлинии      I м⁴
        inMass, mM; -- моменты инерции исходного и текущего объема корпуса G м⁴
*/
#include "Vessel.h"   // объекты и производные операции с корпусом на волнении
                      //  ++ дополнения графической среды OpenGL->Window-Place
static Vector         //! КБ - локальный корабельный базис; МБ - морской базис
       Vship,Wship,   // скорость хода и вектор момента вращения корпуса судна
       vBz;//vFz,     // сохраняемые центр величины
static Real iVz=0;    //        и величина водоизмещения при полном погружении
//static Real
//       pV;          // удвоенный скоростной напор/давление по ходу корабля
void
Hull::ThreeInitial()  // начальная очистка всех величин динамических параметров
{ iV=iS=iF=0.0;       // скалярные собраны в кучу, векторные - все производные
  mW=0.0; mM=0.0;     // тензорные объекты в том же ранге срочных перерасчетов
  vBz=vB; vB=0; vF=0; // сумматоры для задействования ранее вычисленных величин
//vBz.x=Buoyancy.x;   // приведение абсциссы плеч тетраэдров/треугольников
  vM =vS =vR=0.0;     // метацентр, силы и моменты от перепадов уровней у борта
  Vship=((Route[-1]-Route[-2])/(Storm->Tstep/Storm->tKrat))/Tensor(*this);// КБ
  Wship=Whirl[-1];    // скорости выше реальные и по расчёту вращательные  в КБ
  if( !Storm->Kt )    // если самое первое обращение - место конструктора Hull
    { Volume=Surface=Floatage=0.0; inWater=0.0; inMass=0.0; vBz=0.0; iVz=0.0; }
//pV = norm( Vship );
}
//inline _Vector operator~( _Point P ){ return *((Vector*)(&P)); }
//inline operator Vector( _Point P ){ return *((Vector*)(&P)); }

void Hull::Three( int Level,  // -2-днище; -1-вода; 0-в-линия; 1-воздух; 2-борт
    _Vertex a,_Vertex b,_Vertex c )   //! динамический перерасчет параметров
{ if( Level<=0 )                      // борт, общекорабельная архитектура мимо
  { Vector S= ( (a-c)*(b-c) )/2.0,    // нормаль с площадью от элемента обшивки
           L= ( a + b + c )/3.0,      // центр площади к треугольнику в обшивке
           M= L * 0.75;               // центр объема к элементарному тетраэдру
    Real   V= ( c % S )/3.0,          // водоизмещение элементарного тетраэдра
           W= abs( S );               // площадь малого треугольника на обшивке
//         M.x=L.x-=Buoyancy.x;       // всем центрам общая абсцисса плавучести
           iV += V;                   // суммирование тетраэдров водоизмещения
           vB += M*V;                 // векторная сборка статических моментов
    if( !Storm->Kt )                  // моменты инерции объема/массы корпуса
    { Matrix J;                       // временно из общей механики исключается
      J.x.x=a.y*a.y+b.y*b.y+c.y*c.y + a.z*a.z+b.z*b.z+c.z*c.z
          + a.y*b.y+a.y*c.y+b.y*c.y + a.z*b.z+a.z*c.z+b.z*c.z;
      J.y.y=a.x*a.x+b.x*b.x+c.x*c.x + a.z*a.z+b.z*b.z+c.z*c.z
          + a.x*b.x+a.x*c.x+b.x*c.x + a.z*b.z+a.z*c.z+b.z*c.z;
      J.z.z=a.x*a.x+b.x*b.x+c.x*c.x + a.y*a.y+b.y*b.y+c.y*c.y
          + a.x*b.x+a.x*c.x+b.x*c.x + a.y*b.y+a.y*c.y+b.y*c.y;
      J.x.y=J.y.x=( a.x*b.y+a.x*c.y+b.x*c.y + a.y*b.x+a.y*c.x+b.y*c.x )/-2.0
                  - a.x*a.y - b.x*b.y - c.x*c.y;
      J.x.z=J.z.x=( a.x*b.z+a.x*c.z+b.x*c.z + a.z*b.x+a.z*c.x+b.z*c.x )/-2.0
                  - a.x*a.z - b.x*b.z - c.x*c.z;
      J.y.z=J.z.y=( a.y*b.z+a.y*c.z+b.y*c.z + a.z*b.y+a.z*c.y+b.z*c.y )/-2.0
                  - a.y*a.z - b.y*b.z - c.y*c.z;
//    J.x.y=J.y.x = ( 2*a.x*a.y + 2*b.x*b.y + 2*c.x*c.y
//        + a.x*b.y+a.x*c.y+b.x*c.y + a.y*b.x+a.y*c.x+b.y*c.x )/-2.0;
//    J.x.z=J.z.x = ( 2*a.x*a.z + 2*b.x*b.z + 2*c.x*c.z
//        + a.x*b.z+a.x*c.z+b.x*c.z + a.z*b.x+a.z*c.x+b.z*c.x )/-2.0;
//    J.y.z=J.z.y = ( 2*a.y*a.z + 2*b.y*b.z + 2*c.y*c.z
//        + a.y*b.z+a.y*c.z+b.y*c.z + a.z*b.y+a.z*c.y+b.z*c.y )/-2.0;
      mM += ( J *= V/10.0 );
    }
    if( Level<0 )      //! здесь только подводная часть корпуса без ватерлинии
    { iS += W;         // скаляр площади смоченной поверхности судовой обшивки
      if( Statum>1 )   // если внешнее давление на треугольники и пары сил в КБ
      { Point R = out( L );                          // центр треугольника в МБ
        Real Hz = R.Z+Storm->Value( R );// вертикаль элементарной площадки в МБ
//      Hd=Hz-(sqr(a.Z-Hz)-(b.Z*b.Z+c.Z*c.Z+3*a.Z*(a.Z-b.Z-c.Z)+b.Z*c.Z)/6)/Hz;
        if( Statum>2 ) // варианты поправок к скоростям потоков у борта корабля
        { Vector v=Vship+( L-vBz )*Wship,s=dir( S );   // скорость треугольника
          if( Statum>3 )   // существенная корректировка скорости под волнением
          { Vector Q; //,R=(_(a)+_(b)+_(c))/3; Storm->Wave( Storm->Trun,R,Q );
            Storm->Wave( Storm->Trun,*(Vector*)(&R),Q ); // смещение и скорость
            v += Q/Tensor(*this);                        // частицы жидкости
          } // else v.x=(Vship/Tensor(*this)).x;  -- исключение подтормаживания
          Real nv=s%v;    // нормальная компонента для перепадов под Торричелли
          Hz -=( norm( Vship ) - norm( s*v ) + copysign( nv*nv,nv ) )/(_g*2.0);
        }
        vR += Hz*( S*( L-vBz ) );   // и моментов от центра величины  [Н·м/ρ]KБ
        vS += Hz * S; // накопительный вектор сил давления треугольников[Н/ρ]КБ
      }
    }             //! теперь всё, что относится к уровню действующей ватерлинии
    else          // -- первые две вершины по одному борту, третья - по другому
    { iF += W;    // - площадь действующей ватерлинии в корабельных координатах
      vF += L*W;  // момент для вычисления центра площади ватерлинии{x4/3} в КБ
      vW += S;    // ещё один векторный элемент интегральной площади ватерлинии
      //   обоснованность задействования перепадов давления на противоположных
      //   бортах не сильно велика, но по эффекту не особо действенна и пагубна
      if( Statum==1 ) //! силы и моменты по уровням на треугольниках ватерлинии
      { Vector F; // элемент силы в глобальной морской системе координат - в МБ
        F.y=( 0.5*(a.w+b.w)-c.w ) * (( a.y+b.y<2*c.y )?-0.5:0.5);   /// правило
        F.y=( F.y*dir( (Vector){x.y,-x.x} )/Tensor(*this) )%S;      //!  знаков
        F.x=( (0.5*(a.w-b.w)*dir((Vector){x.x,x.y}))/Tensor(*this) )%S; F.z=0;
                   // горизонтальный вектор поступательной качки корабельной СК
        vS += F;         // величина горизонтальной сдвиговой силы в КБ   [Н/ρ]
        vR += F*(L-vBz); // разворачивающий момент дрейфа на склонах волн [Н·м]
      }
     Real ar=hypot( a.y,a.z ),            // + простая дистанция от оси абсцисс
          br=hypot( b.y,b.z );            // момента инерции площади ватерлинии
      W = fabs( a.x*br-b.x*ar )/12.0;     // иная площадь элементарной площадки
      mW.x.y=                             // моменты инерции площади ватерлинии
      mW.y.x+=( a.x*br/2 + a.x*ar + b.x*br + b.x*ar/2 )*W;    // упорядоченные
      mW.x.x+=(  ar*ar  +  ar*br  +  br*br  )*W;              // фрагменты
      mW.y.y+=( a.x*a.x + a.x*b.x + b.x*b.x )*W;              // ватерлинии в
    }                                                         // морском базисе
  }
}
//!  рассматривается динамика корпуса корабля с переменным водоизмещением и
//!  деформируемыми моментами инерции в условиях интенсивного морского волнения
//
void           // метацентрическая высота hX определяется в исходных данных [м]
Hull::ThreeFixed() // постобработка всех треугольников, фиксация первой статики
{ //
  //  корпус может погрузиться iF==0 или выскочить из воды iV==0
  //             метацентрические расчеты опасны делениями на площади и объёмы
  if( iVz<iV )iVz=iV;  // фиксируется величина водоизмещения полного погружения
  if( iF<Floatage/32 && iV<Volume/32  //! обязательно наличие действующей ватерлинии
  || !iF && iV>Volume ) //! отрыв от поверхности воды (погружение или всплытие)
  { if( Storm->Kt<2 )
      Break( "Ошибка инициализации\n\t(нет ватерлинии на шаге %d)",Storm->Kt );
    vW=Zenit/Tensor( *this ); // направление вектора всплытия вертикально вверх
    vF=Floatable;          // возврат к исходному центру площади ватерлинии
    vM=Metacenter;         // метацентр также по начальной остойчивости
    mW=inWater;            // может быть нулём и центром базиса по определению
    if( iV>Volume )  // полное погружение в подводное положение
    { vB/=iVz;       // положение центра величины в локальных координатах (!?)
    } else           // иначе "летучий голландец" взлетает и парит над волнами
    { mM=inMass;     // массовый момент инерции по честному не может находиться
      vB=Buoyancy;   // центр величины <∨> сбрасывается в исходное положение
    //vB=Gravity;    // для исключения пар сил сводятся центры объёма и тяжести
    //iV=Volume/2;   // на частичное водоизмещение для приводнения после взлёта
  } } else       // и если судно в водоизмещающем состоянии на поверхности моря
  { vB /= iV;    // корабельные координаты центра величины (=подводного объема)
    vF /= iF;    // условный центр площади ватерлинии по горизонту,   тоже в КБ
    vW /= iF;    // интегральная нормаль к площади действующей ватерлинии, в КБ
    //
    //  приводим моменты инерции к центру масс и центру площади ватерлинии
    //
    mW = Steiner( mW,vF );  // моменты инерции исходной площади ватерлинии I м⁴
  //mW *= abs( vW );        // поправка на уменьшение интегральной площади I(~)
  //mM=Steiner( mM,vB,Gravity );        // ++ инерции массы/объема корпуса G м⁵
                                        // = переходит сначала на ЦВ затем к ЦТ
  //if( Statum>1 )                      // вместо приведения к центральной силе
       vR = dir( vR )*( vR%dir( vS ) ); // вычисляется минимум осевого момента


    //
    // метацентр искусственно вводится k фиксации аппликаты центра масс/тяжести
    //
//  vM = vB;        // по горизонту метацентр будет строго над центром величины
//  vM +=(Vector){ 0,0,mW.x.x/Volume }/Tensor(*this);      // сдвиг вверх вдоль
                // условной аппликаты поперечного метацентра - центр кренования
//  vM.y = vB.z+mW.y.y/iV;        // и продольного метацентра ~~ удифферентовки

   Vector A=Tensor(*this)*vB,          // Во внешней морской системе координат
          B=Tensor(*this)*Gravity;
    if( !Storm->Kt )Volume=iV;
//  vM.x=copysign( A.z+mW.x.x/Volume,z.z );// аппликата поперечного метацентра
//  vM.y=copysign( A.z+mW.y.y/Volume,z.z );// продольного метацентра, дифферент
    vM.x = A.z + mW.x.x/Volume;            // аппликата поперечного метацентра
    vM.y = A.z + mW.y.y/Volume;            // продольного метацентра, дифферент
    vM.z = vM.x-B.z;       // hX(z) мгновенное значение метацентрической высоты
  }                 // в первом вхождении метацентрическая высота задается явно
  if( !Storm->Kt ) //! фиксация начальных гидростатических характеристик   в КБ
  { Volume=iV;     // исходное водоизмещение, мгновенный погруженный объем V м³
    Surface=iS;    // подводная и смоченная поверхность корпуса            S м²
    Floatage=iF;   // исходная и действующая площадь ватерлинии            F м²
    Gravity=vB;    // центр тяжести в локальных корабельных координатах    G м
    Gravity.z=vM.x-hX; // аппликата центра масс встанет строго ниже метацентра hX м
    Metacenter=vM; // аппликаты теоретических и текущих метацентров   Zm,ZM,h м
    Buoyancy=vB;   // координаты центра величины,центра объема корпуса     cB м
    Floatable=vF;  // центр площади исходной и действующей ватерлинии      cF м
    inWater=mW;    // моменты инерции исходной площади ватерлинии          I м⁴
    inMass=Steiner( mM,vB,Gravity );    // ++ инерции массы/объема корпуса G м⁵
    Storm->Kt=1;                        // = переходит сначала на ЦВ затем к ЦТ
  } //!    Kt≠0 - предотвращает повторы вычислений начальных данных по корпусу
}
//!    динамика корпуса под действием внешних сил и моментов волновой природы
//        ~~ здесь вычислительный шаг во времени задаются по куранту для самых
//           быстрых волн, и еще предстоит это поправить на динамику корабля
//!    оси угловой качки сводятся к центру тяжести с аппликатой мгновенного
//     центра величины (погруженного объёиа) в корабельной системе координат
//     (иначе неадекватные скорости течений вблизи обшивки)
//
Hull& Hull::Moving( _Real Ts )
{ Vector V=Rate[-1],  // поступательная - вектор полной скорости хода и дрейфа
        W=Whirl[-1],  // и мгновенная угловая скорости движения корпуса корабля
// Locate=Route[-1], === текущее местоположение с учетом вертикального всплытия
      Dir=Swing[-1], // величины действующих углов x-крен y-дифферент z-рыскание
      R,U;          // действующий градиент наклона волновой поверхности
  Field &Sea=*Storm;
  //
  //  быстрый градиент волнового склона по кресту четырех противоположных точек
  //
  if( Statum<2 )// скользящая кинематика + по направлению действия объемных сил
  { Vector A,B,C,D,E;
    A = Sea.Locus( out( Zero ) );              // положение корабельного базиса
    B = Sea.Locus( out((Vector){Length/4}))-A; // всё-таки градиент инвариантен
    C = Sea.Locus( out((Vector){Length/-4}))-A; // не зависит от осевого базиса
    D = Sea.Locus( *(Point*)( &(R=A+(E=((Breadth/Length)*(C-B))*Zenit)) ) )-A;
    E = Sea.Locus( *(Point*)( &(R=A-E) ) )-A;
    U = dir( B*D + D*C + C*E + E*B )  // вектор в морской системе координат МБ
      * rolZ( -Dir.z );               // c выбором базиса по корабельному курсу
    R = A+(B+C+D+E)/4.0;              // == у всех треугольников одинаковый вес
  }               //  свободно-жесткий вариант (°) лагом/вразрез/носом на волну
  if( !Statum )   //! пока простое статическое касание поверхности склонов волн
  {               //! +сделано скольжение по склонам с инерцией по ходу и качке
                  //  координаты: половина кормового и носового перпендикуляров
    //      после смены курса определяем местоположение оконечностей(без качки)
    //      затем вычисляем аппликаты волн по неким габаритным размерам корпуса
//  U=( Tensor(*this)*vW )* rolZ( -Dir.z ); // к случаю интегрального градиента
    Dir.y = atan2( U.x,U.z );      // расчёт угла дифферента
    Dir.x = atan2(-U.y,U.z );      // выбор нового угла крена
#if 0
    axiY( angle( Dir.y ) );        // дифферент | фиксация положения корпуса
    rotX( angle( Dir.x ) );        // +крен     | начиная от условно малых
    rotZ( angle( Dir.z ) );        // +рыскание | углов: дифферент-крен-курс
#else
    axiZ( Dir.z );                 // рыскание: в три угла: курс-дифферент-крен
    Rotate( Dir.y,y );                // +дифферент: приведение положения корпуса
    Rotate( Dir.x,x );                // +крен: на условно больших углах поворотов
#endif
    V.x += Dir.y * _g*Ts;          // ускорение и скорость скользящего движения
    V.y -= Dir.x * _g*Ts;          //             по градиенту волнового склона
    V.z = ( R.z-Z )/Ts;            // скорость по вертикальной качке
    Z = R.z;                       // изменение аппликаты посадки на миделе КВЛ
    W = (Dir-Swing[-1])/Ts;        //    скорость изменения курса и углов качки
    R = 0; //Tensor(*this)*(W*Ts); //   чтоб без дополнений в динамике качки MБ
  }
  //  изначально эксперимент строился только на главных компонентах архимедовых
  //  сил всплытия по вертикали, как бортовая, килевая и вертикальная качка/нет
  //   и все другие варианты объёмной гидро(статической)динамической постановки
  //                          корпуса корабля на морскую волну большой крутизны
  else
  { Vector B = vS; // суммарное действие давления в смоченно-изменчивой обшивке
    //
    //  вычисления соотносятся с гравитационным центом тяжести и мгновенным
    //  или действующим центром величины, при этом внешние силы определяются во
    //  внешней морской системе координат, в то время как реакция и приращения
    //  скоростей в локальном корабельном базисе (как-то так видится с мостика)
    //                     корабельная система координат (КБ) корабельный базис
    //
//  if( Statum==1 )B += iV*( U/Tensor(*this) );
//  if( Statum==1 )B += iV*dir( vW );
    if( Statum==1 )B += iV*vW;
//  if( Statum==1 )B += iV*Zenit/Tensor(*this);
    //
    //  объёмные или поверхностные силы Архимедового всплытия без ρ/ρ      в КБ
    //               водоизмещение - гравитационная сила массы корпуса
    //
    V += ( _g*Ts/Volume )           // гравитационная разность по водоизмещению
       * ( B + (Vector){ 0,0,-Volume }/Tensor( *this) );
                                   //  приращение скорости поступательной качки
    //
    //! бортовая, килевая качка и рыскание - дрейф: F=ρ∙g∙h∙S/2; a=F/V; dV=a∙dt
    // здесь центры масс и величины отмеряются относительно исходной ватерлинии
    // плечо центра тяжести относительно мгновенно-переменного центра величины
    //
    R = vB-Gravity;     // большое плечо для момента архимедового всплытия в КБ
    //
    // Волновые воздействия задаются архимедовыми силами всплытия по градиентам
    //    поверхностей равных давлений, и с величиной погруженной части корпуса
    // Вектор сил тяжести, проходящий через динамический центр, не создает
    //    никаких кренящих моментов.
    //! ~~ если корпус выходит из воды, то волновое воздействие прекращается.
    //
    B = _g*( R*B );    // ω=ε·t большие архимедовы моменты в корабельном базисе

    if( Statum==1 )             //?? здесь или центр тяжести или центр величины
      B +=_g*( vF-Gravity )*vS; //?? момент вращений от дрейфовых сдвигов на ВЛ
    //
    //   установка внешней гидростатики в местной корабельной системы координат
    //
//  if( Statum>1 )             //?? пока исключено по причине сильного рыскания
      B += _g*vR;              // свободная качка и рыскание на склонах волн /ρ
    //
    // боковые смещения полностью гасятся моментом простого крена на циркуляции
    // таким образом пусть любое ускорение центра масс образует момент пары сил
    //                 относительно действующего центра величины (не от осадки)
    //                                      и плечо в морскую систему отсчётов
    if( Route.length>3 )
      B += (Volume/Ts)*(R*((Route[-1]-2.0*Route[-2]+Route[-3])/Tensor(*this)));
    //
    //  Моменты в ускорения поворотов -> скорости вращения -> угловые положения
    //
    W += Ts*(B/Tensor(inMass)); // угловые дифференциалы приращения поворотов/ρ
                            // суммирование скоростей крена.дифферента.рыскания
/*
cprint( 1,26,"Dir.x=%0.3g ==> %0.3g   ",DampM.x*Ts,
                                        DampM.x*( 1+16*fabs(Dir.x)/_Pi )*Ts );
*/
    W.x /= exp( DampM.x*( 1+12*sqr( Dir.x/_Pi ) )*Ts );
    W.y /= exp( DampM.y*Ts );                //! демпфирование полных величин
    W.z /= exp( DampM.z*Ts );                //        угловых скоростей
    { Real w=max( fabs(W.x),max( fabs(W.y),fabs(W.z) ) );
      if( w>_Pi/6.0 )W *= _Pi/w/6.0;      //_Pd/6 полный оборот ≈ 6 сек /оверкиль ≈ 3 сек
    }
    R = W*Ts;              // здесь лишь приращение собственно углов качки,  КБ
                           //  новая тройка угловых наклонов и рысканий корпуса
//  R = Tensor(*this)*R;   //  и переход в глобальную морскую систему координат
  }                        // координатные оси корабельного базиса в морской СК
  //
  //!   переработка результатов динамического позиционирования и автоматическое
  //!       управление ходом и курсом корабля на штормовой волне
                                         // приращение скорости поступательной
  V.x = cSp-(cSp-V.x)/exp( DampF.x*Ts ); // качки по сопоставлению с предыдущим
  V.y = V.y/exp( DampF.y*Ts );     // если м=0 - проходит; м>0 - подтормаживаем
  V.z = V.z/exp( DampF.z*Ts );    // демпфирование поступательной скорости в КБ
  // для изменчивого хода необходимо устраивать соревнование с тягой движителей
  // - или плавное управление ходом корабля с неким предопределенным ускорением
  // = по сути а-ля преодоление сопротивления пропорционально квадрату скорости
  {
   Real dV=cSp-V.x; V.x += 0.03*copysign( dV*dV,dV )*Ts*Surface/Volume;
    //    Speed += 0.1*( dV )*Ts; == простоe ускорение декремента затухания м/с
    //
    //  управление курсом корабля с выбором относительно медленной циркуляции
    //
   static bool Kurs=true;   // на заданном курсе - изначально выставляется Норд
               // Ty=x*Zenit - азимут по правому траверзу в плоскости горизонта
   Vector Tr = Zenit*(x*Zenit);    // курс <= перпендикуляр от правого траверза
   Real dR=angle( Course,atan2( -Tr.y,Tr.x ) ),   // все углы от -180° до +180°
        dA=copysign( (ScanStatus()&ALT)?0.0:dCs*Ts,z.z );  // задержка поворота
    if( fabs( dR )<0.1*_dR )Kurs=true,dCs=_Ph/60; // на курсе плавное удержание
    if( fabs( dR )<_Pi/32 && Kurs )dR=0.0; else
    { Kurs = false;
      R.z -= ( dR=minmax( -dA,dR,dA ) );     // ограничение скорости циркуляции
//    Dir.z-=dR;   // небольшое уточнение чисто для информации без привода в КБ
    }
    //! с учетом отсутствия контроля локальных скоростей
    //  ограничивается скорость вращений до 3° за шаг во времени
    //
//      R.y = copysign( min( 0.06,fabs( R.y ) ),R.y ); //  3°
//      R.x = copysign( min( 0.21,fabs( R.x ) ),R.x ); // 12°
//      R.z = copysign( min( 0.11,fabs( R.z ) ),R.z ); //  6°
    if( Statum )
      { Rotate( R.y,y );     //++ дифферент в MБ - всё теперь в дифференциалах
        Rotate( R.x,x );     //++ крен      в KB = много вопросов при аппликате
      } Rotate( R.z,Zenit ); //++ рыскание  в ?? ~ отклонение курса в вертикали
    //
    // что бы ни получили в проворотах, требуется корректура угловых отсчётов
    //     ~~ вынужденная проблема корректировки курсовых углов и углов качки
    //
    Tr = Zenit*(x*Zenit);  // курс = перпендикуляр в горизонте правого траверза
    Dir.z=atan2( Tr.y,Tr.x );     // корректировка систематической девиации
    if( Statum )                  // ~~ нет режима кинематического скольжения
    { Tr = Tr/Tensor(*this);      // тем же курсом к продольному дифференту  КБ
      Dir.y=atan2( Tr.z,Tr.x );   // по обратному отсчету по подъему горизонта
      Tr = Zenit/Tensor(*this);   // зенит во взгляде в корабельных координатах
      Dir.x=atan2( Tr.y,Tr.z );   // крен в заглублении отсчёта оси ординат  КБ
    }
    // ежесекундная отметка навигационной информации на консоли(признак работы)
    //
   static Real Tz=0; // и посекундная выдача динамики хода на текстовую консоль
    if( Sea.Trun-Tz>1.0 ){ Tz=Sea.Trun; textcolor( LIGHTCYAN );
        cprint( 2,22," Курс( ∂ )заданный => %.1f°<%.1f> %.1f°     \n"
                     "           крен %3.1f°,  дифферент %3.1f°   \n"
                     "           Скорость %3.1f из %3.1f узлов    \n",
                     -Dir.z*_Rd,dR*_Rd,Course*_Rd,Dir.x*_Rd,Dir.y*_Rd,
                     Speed*3600/_Mile,cSp*3600/_Mile ),gotoxy( 2,22 );
  } }
  // дополнение скорости хода по текущему курсу, построение траектории движения
  //
  Whirl += W;        // угловые скорости изменения курса, крена и дифферента КБ
  Swing += angle( Dir ); // величины осевых углов Крылова-Эйлера(временно) в МБ
                         // выбор нового местоположения вдоль маршрута движения
//U=vB; U.x=Gravity.x;
//U=( Gravity*Volume + vB*iV )/( Volume+iV );
  U=( Buoyancy*Volume + vB*iV )/( Volume+iV );
  Route += ( Locate += Matrix(*this)*((V+U*W)*Ts) ); // +Matrix(*this)*Gravity;
//Route += ( Locate += Matrix(*this)*( V*Ts ) );
                      //  центр корабельного базиса  и собственно маршрут  в МБ
                      // поступательные скорости под действием архимедовых сил
  Rate += V;          // всплытия, и градиентов давления под волновыми склонами
  Speed = V.x;        // результирующая скорость хода для информационных нужд
  Z = Locate.z;       // ++ отклонение по аппликате от исходного центра масс МБ
  return *this;   // вертикаль центра отсчета согласует осадку с водоизмещением
}
/*  пока так издревле повелось с тремя углами Эйлера-Крылова
    (проблемы с большими углами поворотов, в отладках приходилось мириться)
       axiY( angle( Dir.y ) ), -- дифферент
       rotX( angle( Dir.x ) ), ~~  +крен
       rotZ( angle( Dir.z ) ); ==  +рыскание
*/
