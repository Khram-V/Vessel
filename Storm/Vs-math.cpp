//
//   Здесь собраны все инициализации и собственно расчетные операции
//      по моделированию динамики корпуса на волнении
/*                                                          ©2020-11-21 ‏יְרוּשָׁלַיִם
  ==
  == геометрия корпуса, состояние движения и маршрутные записи курса и скорости
  ==
 Real Length,Breadth,Draught,     -- конструктивные длина, ширина и осадка  [м]
      Course,dCs,   -- курс корабля и обратное время для полуциркуляции п·dT/30
      Speed, cSp;   -- настоящая и устанавливаемая скорость хода корабля  [м/с]
 Vector Locate;     -- местоположение корабля для отсчётов волновых полей   [м]
 Flex Route,        -- маршрут - траектория контролируемого хода корабля    [м]
      Rate,         -- скорости смещения корпуса в корабельном базисе     [м/с]
      Swing,Whirl;  -- и вращательных движения корпуса в углах Крылова  [р,р/с]
 byte Statum;   --   0 - жесткое кинематическое позиционирование корпуса над
                --       волнением по хордам на четырёх точках, иначе:
                --   1 - объёмное гравитационное всплытие: борт-киль-вертикаль
                --   2 - гидростатическое давление по смоченной обшивке в волне
                --   3 - касательная компонента скорости под волновыми гребнями
                --   4 -  и вихреисточники обтекания корпуса набегающим потоком
                --  ~~ ~ полные потоки в механике отражения волн(в перспективе)
                --  ++ ~ обтекание корпуса с трохоидальными волнами по глубине
                --  ~~ - динамическое изменение тензора инерции и центра масс
                --  ~~ - перепады давления по градиентам поверхности ватерлинии
 byte DrawMode;     --   0 - ватерлиния строится при любом раскладе
                    --   1 - только собственно штевни и шпангоуты
                    --   2 - подводная часть со шпангоутами над водой
                    --   3 - весь корпус прорисовывается целиком
                    -- х04 - тоже, но только с триангуляционными ребрами
                    -- х10 - разблокировка графики и включение надводного борта
   -- размерения и динамические параметры корпуса корабля (Volume=0-обновление)
   -- локальная корабельная система координат определяется в составе структуры
   -- Hull::Base и включает координаты пространственного местоположения
   -- Point{X,Y,Z} и тензор тривекторов поворотов Matrix::Vector{x,y,z}
   --
 Real hX, // поперечная метацентрическая высота задаёт аппликату центра тяжести
      Volume,  iV, -- исходное водоизмещение, мгновенный погруженный объем V м³
      Surface, iS, -- подводная и смоченная поверхность корпуса            S м²
      Floatage,iF, -- исходная и действующая площадь ватерлинии            F м²
  //  SecInert,iX, -- ==>inWater -=- момент инерции площади ватерлинии     I м⁴
      sT;          -- интервал времени для графиков кинематики XYZ-качки    сек
 Vector Gravity,       -- центр тяжести в локальных корабельных координатах  G
        Buoyancy,  vB, -- координаты центра величины,центра объема корпуса   cB
        Floatable, vF, -- центр площади исходной и действующей ватерлинии    cF
                   vW, -- нормаль к интегрированной площади ватерлинии      (δ)
                   vS, -- накопительный вектор сил от перепадов уровней   [H/ρ]
                   vR, -- вращательный момент искривленно-наклонной ватерлинии
  //               vW, -- проекции на вертикальные плоскости &Waterside      м²
  //               vP, -- центры горизонтальных давлений по дрейфу и ускорению
        Metacenter,vM, -- аппликаты исходного+текущего метацентров  Zm(x),ZM(y)
                       --  ++ мгновенная величина метацентрической высоты  h(z)
        DampF, DampM;  -- демпфирование (>0) до исключения(=1) скорости качки
 Matrix inWater,mW, -- моменты инерции площади действующей ватерлинии      I м⁴
        inMass, mM; -- моменты инерции исходного и текущего объема корпуса G м⁴
*/
#include "Vessel.h"   // объекты и производные операции с корпусом на волнении
                      //  ++ дополнения графической среды OpenGL->Window-Place
static Vector         //! КБ - локальный корабельный базис; МБ - морской базис
       Vship,Wship,   // скорость хода и вектор момента вращения корпуса в КБ
       vBz;//vFz,     // сохраняемые центр величины
static Real iVz=0;    //        и величина водоизмещения при полном погружении
//static Real
//       pV;          // удвоенный скоростной напор/давление по ходу корабля
void
Hull::ThreeInitial()  // начальная очистка всех величин динамических параметров
{ iV=iS=iF=0.0;       // скалярные собраны в кучу, векторные - все производные
  mW=0.0; //mM=0.0;   // тензорные объекты в том же ранге срочных перерасчетов
  vBz=vB; vB=0; vF=0; // сумматоры для задействования ранее вычисленных величин
//vBz.x=Buoyancy.x;   // приведение абсциссы плеч тетраэдров/треугольников
  vM =vS =vR=0.0;     // метацентр, силы и моменты от перепадов уровней у борта
  Vship=((Route[-1]-Route[-2])/(Storm->Tstep/Storm->tKrat))/Tensor(*this);// КБ
  Wship=Whirl[-1];    // скорости выше реальные и по расчёту вращательные  в КБ
  if( !Storm->Kt )    // если самое первое обращение - место конструктора Hull
    { Volume=Surface=Floatage=0.0; inWater=0.0; inMass=0.0; vBz=0.0; iVz=0.0; }
//pV = norm( Vship );
}
//inline _Vector operator~( _Point P ){ return *((Vector*)(&P)); }
//inline operator Vector( _Point P ){ return *((Vector*)(&P)); }

void Hull::Three( int Level,  // -2-днище; -1-вода; 0-в-линия; 1-воздух; 2-борт
    _Vertex a,_Vertex b,_Vertex c )   //! динамический перерасчет параметров
{ if( Level<=0 )                      // борт, общекорабельная архитектура мимо
  { Vector S =( (a-c)*(b-c) )/2.0;    // нормаль с площадью от элемента обшивки
    Real   W =abs( S );               // площадь малого треугольника на обшивке
    if( W<eps )return;                // -- сброс обнулённого фрагмента
    Vector s=S/W,                     // ориентация нормали треугольника
           L =( a + b + c )/3.0,      // центр площади к треугольнику в обшивке
           M = L * 0.75,              // центр объема к элементарному тетраэдру
           Sz=( (Point(a)-Point(c))*(Point(b)-Point(c)) )/2; // ориентация в МБ
    Real   V =( c % S )/3.0;          // водоизмещение элементарного тетраэдра
           iV += V;                   // суммирование тетраэдров водоизмещения
           vB += M*V;                 // векторная сборка статических моментов
//         M.x=L.x-=Buoyancy.x;       // всем центрам общая абсцисса плавучести
    if( !Storm->Kt )                  // моменты инерции объема/массы корпуса
    { Matrix J;                       // временно из общей механики исключается
      J.x.x=a.y*a.y+b.y*b.y+c.y*c.y + a.z*a.z+b.z*b.z+c.z*c.z
          + a.y*b.y+a.y*c.y+b.y*c.y + a.z*b.z+a.z*c.z+b.z*c.z;
      J.y.y=a.x*a.x+b.x*b.x+c.x*c.x + a.z*a.z+b.z*b.z+c.z*c.z
          + a.x*b.x+a.x*c.x+b.x*c.x + a.z*b.z+a.z*c.z+b.z*c.z;
      J.z.z=a.x*a.x+b.x*b.x+c.x*c.x + a.y*a.y+b.y*b.y+c.y*c.y
          + a.x*b.x+a.x*c.x+b.x*c.x + a.y*b.y+a.y*c.y+b.y*c.y;
      J.x.y=J.y.x=( a.x*b.y+a.x*c.y+b.x*c.y + a.y*b.x+a.y*c.x+b.y*c.x )/-2.0
                  - a.x*a.y - b.x*b.y - c.x*c.y;
      J.x.z=J.z.x=( a.x*b.z+a.x*c.z+b.x*c.z + a.z*b.x+a.z*c.x+b.z*c.x )/-2.0
                  - a.x*a.z - b.x*b.z - c.x*c.z;
      J.y.z=J.z.y=( a.y*b.z+a.y*c.z+b.y*c.z + a.z*b.y+a.z*c.y+b.z*c.y )/-2.0
                  - a.y*a.z - b.y*b.z - c.y*c.z;
//    J.x.y=J.y.x = ( 2*a.x*a.y + 2*b.x*b.y + 2*c.x*c.y
//        + a.x*b.y+a.x*c.y+b.x*c.y + a.y*b.x+a.y*c.x+b.y*c.x )/-2.0;
//    J.x.z=J.z.x = ( 2*a.x*a.z + 2*b.x*b.z + 2*c.x*c.z
//        + a.x*b.z+a.x*c.z+b.x*c.z + a.z*b.x+a.z*c.x+b.z*c.x )/-2.0;
//    J.y.z=J.z.y = ( 2*a.y*a.z + 2*b.y*b.z + 2*c.y*c.z
//        + a.y*b.z+a.y*c.z+b.y*c.z + a.z*b.y+a.z*c.y+b.z*c.y )/-2.0;
      inMass += ( J *= V/10.0 );
    }
    if( Level<0 )     //! гидростатика с гидродинамикой обводов ниже ватерлинии
    { iS += W;        // + скаляр площади смоченной поверхности судовой обшивки
      if( Statum>1 )  // если внешнее давление на треугольники и пары сил  в КБ
      { Vector Cz=L;  // здесь будет местоположение точки действия сил давления
        Point R=out( L );           // центр элементарного треугольника    в МБ
        Real Hz=R.Z-Storm->Value(R);// подводная вертикаль центра давления в МБ
        if( Hz<-eps && W>eps )      // поправки по вертикали для центра силы
        { Vector C=Zenit*(Sz/W);    // длина к синусу угла вертикали с нормалью
          if( norm( C )>eps )       // и если треугольник не горизонтален
          { Real az=a.Z-a.w, bz=b.Z-b.w, cz=c.Z-c.w,  // погружение вершин в МБ
            d =( az*(az-bz-cz)/2 + (bz*bz+bz*cz+cz*cz)/6 - sqr(az-Hz) )/Hz;
            C =( dir( C*Sz ) )*(d/abs( C )); // к центру действия силы давления
            Cz= in( R-C );                  // возврат в корабельные координаты
        } }         // гидростатика всегда есть в интегралах по судовым обводам
        vS += Hz*S; // накопительный вектор сил давления треугольников  [Н/ρ]КБ
        vR += Hz*( S*( Gravity-Cz ) ); //+ моменты от центра величины [Н·м/ρ]KБ

        //
        //  Здесь гидростатика дополняется компонентами скоростных потоков для
        //        для взаимовлияния хода, качки и всех штормовых воздействий
        //
        if( Statum>2 )
        { Vector v=Vship // *(1+Breadth/Length/2) - т.е. для шара получится 1,5
               + Wship*( L-Gravity ); // скорость треугольника, правило знаков?
          if( Statum>3 ) // волновые воздействия с быстрыми подводными потоками
          { Vector Q;   // выборка скорости течения под волной по координатам R
            Storm->Wave( Storm->Trun,*(Vector*)(&R),Q ); // смещение и скорость
            v -= Q/Tensor(*this);                        // частицы жидкости
          }
          Real nv=s%v;       // нормальная компонента для перепадов давления
          Hz=( norm( v )     // интегральная скорость потока для всего корпуса
            - norm( s*v )    // касательная компонента скорости внешнего потока
            - copysign( nv*nv,nv ) )/(_g*2.0); // и составляющая к непротеканию
          vS += Hz*S;        // накопительный вектор сил давления треугольников
          vR += Hz*( ( L-Gravity )*S );          //++ моменты от центра тяжести
        }
      }
    }             //! теперь всё, это относится к уровню действующей ватерлинии
    else          // -- первые две вершины по одному борту, третья - по другому
    { iF += W;    // - площадь действующей ватерлинии в корабельных координатах
      vF += L*W;  // момент для вычисления центра площади ватерлинии{x4/3} в КБ
      vW += Sz;   // ещё один векторный элемент интегральной площади ватерлинии
      //   обоснованность задействования перепадов давления на противоположных
      //   бортах не сильно велика, но по эффекту не особо действенна и пагубна
      if( Statum==1 ) //! силы и моменты по уровням на треугольниках ватерлинии
      { Vector F; // элемент силы в глобальной морской системе координат - в МБ
        F = 0.5*( 0.5*(a.w+b.w)-c.w )*Sz/W;                // правило знаков !!
        F.z=0.0;           //-- или горизонтальный компонент дрейфовых сил в MB
        F=F/Tensor(*this); // g -- величина силы определяется вместе с реакцией
        vS+=F;           // величина горизонтальной сдвиговой силы в КБ   [Н/ρ]
        vR+=F*(Gravity-L);// разворачивающий момент дрейфа на склонах волн[Н·м]
      }
     Real ar=hypot( a.y,a.z ),            // + простая дистанция от оси абсцисс
          br=hypot( b.y,b.z );            // момента инерции площади ватерлинии
      W = fabs( a.x*br-b.x*ar )/12.0;     // иная площадь элементарной площадки
      mW.x.y=                             // моменты инерции площади ватерлинии
      mW.y.x+=( a.x*br/2 + a.x*ar + b.x*br + b.x*ar/2 )*W;    // упорядоченные
      mW.x.x+=(  ar*ar  +  ar*br  +  br*br  )*W;              // фрагменты
      mW.y.y+=( a.x*a.x + a.x*b.x + b.x*b.x )*W;              // ватерлинии в
  } }                                                         // морском базисе
}
//!  рассматривается динамика корпуса корабля с переменным водоизмещением и
//!  деформируемыми моментами инерции в условиях интенсивного морского волнения
//
void           // метацентрическая высота hX определяется в исходных данных [м]
Hull::ThreeFixed() // постобработка всех треугольников, фиксация первой статики
{ //
  //  корпус может погрузиться iF==0 или выскочить из воды iV==0
  //             метацентрические расчеты опасны делениями на площади и объёмы
  if( iVz<iV )iVz=iV;  // фиксируется величина водоизмещения полного погружения
  if( iF<Floatage/32 && iV<Volume/32 //! существование действующей ватерлинии
  || !iF && iV>Volume )              //! потеря поверхности воды при погружении
  { if( Storm->Kt<2 )
      Break( "Ошибка инициализации\n\t(нет ватерлинии на шаге %d)",Storm->Kt );
    vW=Zenit/Tensor( *this ); // направление вектора всплытия вертикально вверх
    vF=Floatable;          // возврат к исходному центру площади ватерлинии
    vM=Metacenter;         // метацентр также по начальной остойчивости
    mW=inWater;            // может быть нулём и центром базиса по определению
    if( iV>Volume )  // полное погружение в подводное положение
    { vB/=iVz;       // положение центра величины в локальных координатах (!?)
    } else           // иначе "летучий голландец" взлетает и парит над волнами
    { vB=Buoyancy;   // центр величины <∨> сбрасывается в исходное положение
    //mM=inMass;     // массовый момент инерции корректно здесь не вычисляется
    //vB=Gravity;    // для исключения пар сил сводятся центры объёма и тяжести
    //iV=Volume/2;   // на частичное водоизмещение для приводнения после взлёта
  } } else       // и если судно в водоизмещающем состоянии на поверхности моря
  { vB /= iV;    // корабельные координаты центра величины (=подводного объема)
    vF /= iF;    // условный центр площади ватерлинии по горизонту,   тоже в КБ
//  vW /= iF;    // интегральная нормаль к площади действующей ватерлинии, в КБ
    vW = dir( vW );
//  if( Statum==1 )
//    { vS=vS/Tensor(*this); vR=vR/Tensor(*this); } // в корабельные координаты
    //
    //  приводим моменты инерции к центру масс и центру площади ватерлинии
    //
    mW = Steiner( mW,vF );  // моменты инерции исходной площади ватерлинии I м⁴
  //mW *= abs( vW );        // поправка на уменьшение интегральной площади I(~)
  //mM=Steiner( mM,vB,Gravity );        // ++ инерции массы/объема корпуса G м⁵
                                        // = переходит сначала на ЦВ затем к ЦТ
  //!!  if( Statum>1 )                  // вместо приведения к центральной силе
  //    vR *= dir( vR )%dir( vS );      // вычисляется минимум осевого момента


    //
    // метацентр искусственно вводится k фиксации аппликаты центра масс/тяжести
    //
    // vM = vB;     // по горизонту метацентр будет строго над центром величины
    // vM +=(Vector){ 0,0,mW.x.x/Volume }/Tensor(*this);   // сдвиг вверх вдоль
                // условной аппликаты поперечного метацентра - центр кренования
    // vM.y = vB.z+mW.y.y/iV;     // и продольного метацентра ~~ удифферентовки

   Vector A=Tensor(*this)*vB,          // Во внешней морской системе координат
          B=Tensor(*this)*Gravity;
    if( !Storm->Kt )Volume=iV;
//  vM.x=copysign( A.z+mW.x.x/Volume,z.z );// аппликата поперечного метацентра
//  vM.y=copysign( A.z+mW.y.y/Volume,z.z );// продольного метацентра, дифферент
    vM.x = A.z + mW.x.x/Volume;            // аппликата поперечного метацентра
    vM.y = A.z + mW.y.y/Volume;            // продольного метацентра, дифферент
    vM.z = vM.x-B.z;       // hX(z) мгновенное значение метацентрической высоты
  }                 // в первом вхождении метацентрическая высота задается явно
  if( !Storm->Kt ) //! фиксация начальных гидростатических характеристик   в КБ
  { Volume=iV;     // исходное водоизмещение, мгновенный погруженный объем V м³
    Surface=iS;    // подводная и смоченная поверхность корпуса            S м²
    Floatage=iF;   // исходная и действующая площадь ватерлинии            F м²
    Gravity=vB;    // центр тяжести в локальных корабельных координатах    G м
    Gravity.z=vM.x-hX; // аппликата центра масс встанет строго ниже метацентра hX м
    Metacenter=vM; // аппликаты теоретических и текущих метацентров   Zm,ZM,h м
    Buoyancy=vB;   // координаты центра величины,центра объема корпуса     cB м
    Floatable=vF;  // центр площади исходной и действующей ватерлинии      cF м
    inWater=mW;    // моменты инерции исходной площади ватерлинии          I м⁴
    inMass=Steiner( inMass,vB,Gravity ); // + инерции массы/объема корпуса G м⁵
    Storm->Kt=1;                        // = переходит сначала на ЦВ затем к ЦТ
  } //!    Kt≠0 - предотвращает повторы вычислений начальных данных по корпусу
}
//!    динамика корпуса под действием внешних сил и моментов волновой природы
//        ~~ здесь вычислительный шаг во времени задаются по куранту для самых
//           быстрых волн, и еще предстоит это поправить на динамику корабля
//!    оси угловой качки сводятся к центру тяжести с аппликатой мгновенного
//     центра величины (погруженного объёиа) в корабельной системе координат
//     (иначе неадекватные скорости течений вблизи обшивки)
//
Hull& Hull::Moving( _Real Ts )
{ Vector V=Rate[-1],  // поступательная - вектор полной скорости хода и дрейфа
        W=Whirl[-1],  // и мгновенная угловая скорости движения корпуса корабля
// Locate=Route[-1], === текущее местоположение с учетом вертикального всплытия
      Dir=Swing[-1], // величины действующих углов x-крен y-дифферент z-рыскание
      R,U;          // действующий градиент наклона волновой поверхности
  Field &Sea=*Storm;
  //
  //  быстрый градиент волнового склона по кресту четырех противоположных точек
  //
  if( Statum<2 )  // скользящая кинематика по направлению действия объемных сил
  { Vector A,B,C,D,E;
    A = Sea.Locas( out( Zero ) );            // пять точек в корабельном базисе
    B = Sea.Locas( out((Vector){Length/4}))-A;    // градиент инвариантен любым
    C = Sea.Locas( out((Vector){Length/-4}))-A;      // ориентациям ортогоналей
//  D = Sea.Locas( out((Vector){0,Breadth/4}))-A;
//  E = Sea.Locas( out((Vector){0,Breadth/-4}))-A;
    D = Sea.Locas( *(Point*)( &(R=A+(E=((Breadth/Length)*(C-B))*Zenit)) ) )-A;
    E = Sea.Locas( *(Point*)( &(R=A-E) ) )-A;
    U = dir( B*D + D*C + C*E + E*B )  // вектор в морской системе координат МБ
      * rolZ( -Dir.z );               // c выбором базиса по корабельному курсу
    R = A+(B+C+D+E)/5.0;              // == у всех треугольников одинаковый вес
  }               //
  if( !Statum )   //! свободно-жесткий вариант (°) лагом/вразрез/носом на волну
  { // простое статическое касание поверхности склонов волн половинных размеров
        //+ реализовано гравитационно-инерционное скольжение по склонам волн
        //  затем вычисляем аппликаты волн по неким габаритным размерам корпуса
    U = vW * rolZ( -Dir.z );       // к случаю интегрального градиента
        // после смены курса определяем местоположение оконечностей (без качки)
    Dir.y = atan2( U.x,U.z );      // расчёт угла дифферента
    Dir.x = atan2(-U.y,U.z );      // выбор нового угла крена
    axiZ( Dir.z );                 // рыскание: в три угла: курс-дифферент-крен
    Rotate( Dir.y,y );             // +дифферент: приведение положения корпуса
    Rotate( Dir.x,x );             // +крен: на условно больших углах поворотов
    V.x += Dir.y * _g*Ts;          // ускорение и скорость скользящего движения
    V.y -= Dir.x * _g*Ts;          //             по градиенту волнового склона
    V.z = ( R.z-Z )/Ts;            // скорость по вертикальной качке
    Z = R.z;                       // изменение аппликаты посадки на миделе КВЛ
    W = (Dir-Swing[-1])/Ts;        // скорость изменения курса и углов качки
    R = 0; // W*Ts; //Tensor(*this)*(W*Ts) // чтоб без дополнений в динамике качки MБ
  }
  //  изначально эксперимент строился только на главных компонентах архимедовых
  //  сил всплытия по вертикали, как бортовая, килевая и вертикальная качка/нет
  //   и все другие варианты объёмной гидро(статической)динамической постановки
  //                          корпуса корабля на морскую волну большой крутизны
  else
  { Vector B = vS; // суммарное действие давления в смоченно-изменчивой обшивке
    //
    //      вычисления соотносятся с гравитационным центом тяжести и мгновенным
    //  или действующим центром величины, при этом внешние силы определяются во
    //  внешней морской системе координат, в то время как реакция  и приращения
    //  скоростей в локальном корабельном базисе (как-то так видится с мостика)
    //                     корабельная система координат (КБ) корабельный базис
    //
    if( Statum==1 )B += iV * ( fabs( z.z )>M_SQRT1_2 ? vW:U )/Tensor(*this);
//  if( Statum==1 )B += iV * ( vW/Tensor(*this) );
//  if( Statum==1 )B += iV * Zenit/Tensor(*this);
    //
    //  объёмные или поверхностные силы Архимедового всплытия без ρ/ρ      в КБ
    //               водоизмещение - гравитационная сила массы корпуса
    //
    V += ( _g*Ts/Volume )           // гравитационная разность по водоизмещению
       * ( B + (Vector){ 0,0,-Volume }/Tensor( *this) );
                                   //  приращение скорости поступательной качки
    //
    //! бортовая, килевая качка и рыскание - дрейф: F=ρ∙g∙h∙S/2; a=F/V; dV=a∙dt
    // здесь центры масс и величины отмеряются относительно исходной ватерлинии
    //  плечо центра тяжести относительно мгновенно-переменного центра величины
    //
    R = vB-Gravity;     // большое плечо для момента архимедового всплытия в КБ
    //
    // Волновые воздействия задаются архимедовыми силами всплытия по градиентам
    //    поверхностей равных давлений, и с величиной погруженной части корпуса
    // Вектор сил тяжести, проходящий через динамический центр, не создает
    //    никаких кренящих моментов.
    //
    //! ~~ если корпус выходит из воды, то волновое воздействие прекращается.
    //
//!
    if( Statum==1 )
      B = _g*( R*B );  // ω=ε·t большие архимедовы моменты в корабельном базисе
    else B = _g*vR;

    if( Statum==1 )             //?? здесь или центр тяжести или центр величины
      B +=_g*( vF-Gravity )*vS; //?? момент вращений от дрейфовых сдвигов на ВЛ

    //
    //   установка внешней гидростатики в местной корабельной системы координат
    //
//  if( Statum>1 )             //?? пока исключено по причине сильного рыскания
//    B += _g*vR;              // свободная качка и рыскание на склонах волн /ρ
    //
    // боковые смещения полностью гасятся моментом простого крена на циркуляции
    // таким образом пусть любое ускорение центра масс образует момент пары сил
    //                 относительно действующего центра величины (не от осадки)
    //                                      и плечо в морскую систему отсчётов
    if( Route.length>3 )
      B += (Volume/Ts)*(R*((Route[-1]-2.0*Route[-2]+Route[-3])/Tensor(*this)));
    //
    //  Моменты в ускорения поворотов -> скорости вращения -> угловые положения
    //
    W += Ts*(B/Tensor(inMass)); // угловые дифференциалы приращения поворотов/ρ
                            // суммирование скоростей крена.дифферента.рыскания
/*
cprint( 1,26,"Dir.x=%0.3g ==> %0.3g   ",DampM.x*Ts,
                                        DampM.x*( 1+16*fabs(Dir.x)/_Pi )*Ts );
*/
    W.x /= exp( DampM.x*( 1+12*sqr( Dir.x/_Pi ) )*Ts );
    W.y /= exp( DampM.y*Ts );                //! демпфирование полных величин
    W.z /= exp( DampM.z*Ts );                //        угловых скоростей
    { Real w=max( fabs(W.x),max( fabs(W.y),fabs(W.z) ) );
      if( w>_Pi/6.0 )W*=_Pi/w/6.0; //_Pd/6 полный оборот ≈6 сек \оверкиль ≈3сек
    }
    R = W*Ts;              // здесь лишь приращение собственно углов качки,  КБ
                           //  новая тройка угловых наклонов и рысканий корпуса
//  R = Tensor(*this)*R;   //  и переход в глобальную морскую систему координат
  }                        // координатные оси корабельного базиса в морской СК
  //
  //! переработка результатов динамического позиционирования и автоматическое
  //!     управление ходом и курсом корабля на штормовой волне
                                         // приращение скорости поступательной
    V.x = cSp-(cSp-V.x)/exp(DampF.x*Ts); // качки по сопоставлению с предыдущим
    V.y = V.y/exp( DampF.y*Ts );   // если м=0 - проходит; м>0 - подтормаживаем
    V.z = V.z/exp( DampF.z*Ts );  // демпфирование поступательной скорости в КБ
  //
  // для изменчивого хода необходимо устраивать соревнование с тягой движителей
  // - или плавное управление ходом корабля с неким предопределенным ускорением
  // = по сути а-ля преодоление сопротивления пропорционально квадрату скорости
  {
   Real dV=cSp-V.x; V.x += 0.03*copysign( dV*dV,dV )*Ts*Surface/Volume;
    //    Speed += 0.1*( dV )*Ts; == простоe ускорение декремента затухания м/с
    //
    //  управление курсом корабля с выбором относительно медленной циркуляции
    //
   static bool Kurs=true;   // на заданном курсе - изначально выставляется Норд
               // Ty=x*Zenit - азимут по правому траверзу в плоскости горизонта
   Vector Tr = Zenit*(x*Zenit);    // курс <= перпендикуляр от правого траверза
   Real dR=angle( Course,atan2( -Tr.y,Tr.x ) ),   // все углы от -180° до +180°
        dA=copysign( (ScanStatus()&ALT)?0.0:dCs*Ts,z.z );  // задержка поворота
    if( fabs( dR )<0.1*_dR )Kurs=true,dCs=_Ph/60; // на курсе плавное удержание
    if( fabs( dR )<_Pi/32 && Kurs )dR=0.0; else
    { Kurs = false;
      R.z -= ( dR=minmax( -dA,dR,dA ) );     // ограничение скорости циркуляции
//    Dir.z -= dR; // небольшое уточнение чисто для информации без привода в КБ
    }
    if( Statum )
      { if( fabs( Dir.y+R.y )<_Ph*0.85 )      //- ограничение дифферента до 84°
        Rotate( R.y,dir( Zenit*(y*Zenit) ) ); //+ дифферент от вертикали в МБ
        Rotate( R.x,x );     //+ крен     в KB = строго на корабельной абсциссе
      } Rotate( R.z,Zenit ); //+ рыскание в МБ ~ отклонение курса при вертикали
    //
    // что бы ни получили в проворотах, требуется корректура угловых отсчётов
    //     ~~ вынужденная проблема корректировки курсовых углов и углов качки
    //
    Tr = Zenit*(x*Zenit);  // курс = перпендикуляр в горизонте правого траверза
    Dir.z=atan2( Tr.y,Tr.x );     // корректировка систематической девиации
    if( Statum )                  // ~~ нет режима кинематического скольжения
    { Tr = Tr/Tensor(*this);      // тем же курсом к продольному дифференту  КБ
      Dir.y=atan2( Tr.z,Tr.x );   // по обратному отсчету по подъему горизонта
      Tr = Zenit/Tensor(*this);   // зенит во взгляде в корабельных координатах
      Dir.x=atan2( Tr.y,Tr.z );   // крен в заглублении отсчёта оси ординат  КБ
    //Tr = ( Zenit*(y*Zenit) )/Tensor(*this);
    //Dir.x=atan2( Tr.z,Tr.y );   // -- аналогия ординаты с абсциссой курса
    }
    // ежесекундная отметка навигационной информации на консоли(признак работы)
    //
   static Real Tz=0; // и посекундная выдача динамики хода на текстовую консоль
    if( Sea.Trun-Tz>1.0 ){ Tz=Sea.Trun; textcolor( LIGHTCYAN );
        cprint( 2,22," Курс( ∂ )заданный => %.1f°<%.1f> %.1f°    \n"
                     "           крен %3.1f°,  дифферент %3.1f°  \n"
                     "           Скорость %3.1f из %3.1f узлов   \n",
                    -Dir.z*_Rd,dR*_Rd,Course*_Rd,Dir.x*_Rd,Dir.y*_Rd,
                     Speed*3600/_Mile,cSp*3600/_Mile ),gotoxy( 2,22 );
  } }
  // дополнение скорости хода по текущему курсу, построение траектории движения
  //
  Whirl += W;        // угловые скорости изменения курса, крена и дифферента КБ
  Swing += angle( Dir ); // величины осевых углов Крылова-Эйлера(временно) в МБ
  Rate += V;          // поступательные скорости под действием архимедовых сил
                      // всплытия, и градиентов давления под волновыми склонами
  Speed = V.x;        // результирующая скорость хода для информационных нужд

  if( !Statum )U=0; else // выбор нового местоположения вдоль маршрута движения
  { if( iV>=Volume )U=vB;     //  вращение относительно неподвижной толщи воды,
    else{ Real dV=(Volume-iV)/Volume; U=vB+(Gravity-vB)*dV*dV; }    // или Ц.Т.
//  U = ( Gravity*Volume + vB*iV )/( Volume+iV );
//  U = ( Buoyancy*Volume + vB*iV )/( Volume+iV );
    U.x=Gravity.x;   //?? абсцисса здесь приводится к исходному центру величины
  }                  //   так как в продольных перемещениях нельзя пренебрегать
                     //   выбором точек приложения сил и кинематических реакций
  Route+=( Locate += Matrix(*this)*( (V+U*W)*Ts ) ); // +Matrix(*this)*Gravity;
  Z = Locate.z;   // ++ отклонение по аппликате от исходного центра масс МБ
                  // центр корабельного базиса и собственно траектория хода МБ
  return *this;   // вертикаль центра отсчета согласует осадку с водоизмещением
}
/*  пока и так издревле повелось с тремя неверными углами Эйлера-Крылова
   (проблемы с большими углами поворотов, но в отладках приходилось мириться)
       axiY( angle( Dir.y ) ), -- дифферент
       rotX( angle( Dir.x ) ), ~~  +крен
       rotZ( angle( Dir.z ) ); ==  +рыскание
*/
