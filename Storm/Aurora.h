//
//      Кафедра компьютерного моделирования и многопроцессорных систем
//          факультет Прикладной математики - процессов управления
//              Санкт-Петербургский государственный университет
//      Подсекция мореходных качеств судов в штормовых условиях
//              Сахалинское отделение Российского научно-технического
//              общества судостроителей имени Алексея Николаевича Крылова
//      ‏יְרוּשָׁלַיִם
//!     проект Aurora — штормовой и экстремальный ход корабля
//             корпус —> волны -> графика
//             статика —> динамика -> реакции
//             кинематика —> излучение -> гидромеханика
//
//      <Tab>  - перестроение картинки в различные контуры\профили,
//               под полную цветовую раскраску или расчистку
//      <Enter> - раскраска поверхностей или исходная триангуляционная сетка
//
//      Контуры шпангоутов определяются параметрическими функциями, и потому
//         могут быть неоднозначными (в перспективе ката- и тримараны),
//         и отчего востребуется учет многократного пересечения поверхности
//         воды 1 - левый/кормовой и Nframes+1 - правый/носовой перпендикуляры.
//      Штевни задаются функциями абсциссы и ординаты от аппликаты,
//         и устанавливаются относительно диаметральной плоскости корабля
//         0 - ахтерштевень; Nframes+2 - форштевень.
//      Плоскости днища, палубы и транцев замыкаются на диаметральной плоскости
//         автоматически, т.е. нули в таблице плазовых ординат могут опускаться
//
#ifndef __Aurora_
#define __Aurora_
#include <StdIO.h>
#include "../Window/View.h"       // собственная графическая среда Window-Place
#include "../Window/ConIO.h"      // консольные операции — отладочные текстовки

#define BkColor 0.9,0.95,0.99     // осветлённая монотонная фоновая расцветка
#define LeftFrame 0x80000000      // признак смежного левого(в корму) шпангоута
//#define StemPost  0x20000000    // индексная маска шпаций вблизи форштевня и
//#define SternPost 0x40000000    // в межшпангоутных треугольниках ахтерштевня
//#define FramePost 0xE0000000    // общая маска к особому шпангоутному индексу

const Real eps=1e-5, // ≡0.01 мм - допустимое сближение точек - к малым моделям
     ro=1025.0,      // стандартная плотность морской ~опреснённой воды [кг/м³]
     hW=8.0*_Pi/3.0, // 1.134 - превышение гребня над средним уровнем моря при
                     //         выравнивании скорости частиц с потоком в гребне
                     // 0.614 - снижение уровня / подвсплытие корабля в подошве
                     //         h·k≈0.75 или λ/h≈π·8/3×2 ƒ{⅜}ћ½
       TimeStep=0.5, // Шаг фиксирован для всех волновых структур одинаков[сек]
  tKrat=M_SQRT2*3.0, // Дробление шага во времени в отношении исходного Куранта
  Ts=TimeStep/tKrat, // расчётный интервал для текущего времени с ходом корабля
  WinLines = 50;     // фиксация количества строк текста для графического окна
extern class Hull *Vessel;        // прямой доступ к графическому контексту
extern class Field *Storm;        // для корпуса корабля и его волнового поля
extern FILE *VIL;                 // настройки с протоколами опытовых испытаний
extern const char *Model[];       // строки описаний модели гидромеханики судна
extern const char *ModelWave[];   // характеристика режима морского волнения
extern const char *Rmbs[];        /* N¦Nord, NtO,NNO,NOtN,NO,NOtO,ONO,OtN,
                                     O¦Ost,  OtS,OSO,SOtO,SO,SOtS,SSO,StO,
                                     S¦Su”d, StW,SSW,SWtS,SW,SWtW,WSW,WtS,
                                     W¦West, WtN,WNW,NWtW,NW,NWtN,NNW,NtW
      Flex — пространственная вектор-функция абсолютного скалярного аргумента
           = параметрическое построение неразрывного трехмерного контура/кривой
           # отслеживание векторных величин в зависимости от шага во времени
           k>=0 є { 0÷len-1 } — положительные индексы с прямым отсчётом P[k]
           k<0  є { len+k÷0 } — отрицательные ≡ обратный отсчёт  P[len-k]
*/
class Flex; typedef const Flex& _Flex;             // числовая ссылка-константа
struct Vertex; typedef const Vertex& _Vertex;      //  ≡ процедурный параметр
                                  //
class Flex{ Vector *P;            // пространственный контур на корпусе корабля
public: int len;                  // означенная длина последовательности точек
  Flex(); ~Flex();                // специальная пространственная интерполяция
  Vector& operator[]( int k );    // доступ к конкретной точке [k]
  Vector& Insert( int k );        // вставка новой точки по индексу [k]
  void    Delete( int k );        // точка [k] выталкивается из векторного ряда
  Vector& operator+=( _Vector );  // добавление новой точки р в конец списка
  Vector& operator/=( _Vector );  // замещение р в начале существующей выборки
};
//!   Каждая вершина треугольника содержит морские и корабельные координаты,
//         а также зарегистрированный на данный момент времени уровень моря
//
struct Vertex: Vector,Point       // вершина исчисляемого треугольника обоих СК
{ Real w;                         // и уровень моря над вершиной треугольника
  Vertex( _Vector V ); // { *this=V; } // конструктор и собственно
  Vertex& operator=( _Vector );   // операция присваивания вектора <Vs-view>
  friend bool operator != ( _Vertex a,_Vertex b )
                           { return a.x!=b.x || a.y!=b.y || a.z!=b.z; }
  friend Vector operator - ( _Vector a,_Vertex b ){ return a-(Vector)b; }
  friend Vector operator + ( _Vector a,_Vertex b ){ return a+(Vector)b; }
};
//!   Исходная таблица плазовых ординат и все параметры штормового хода корабля
//
class Hull: public Base,public View // Связный корабельный базис и окно графики
{ int Nframes,Mid;                 // общее количество и номер мидельшпангоута
  Real *Keel;                     // абсциссы шпангоутов под таблицей ординат
  Flex Stern,Stem,                // штевни оконтуривают транцевые расширения
           *Frame,                //   и собственно список шпангоутных контуров
        WaterLine,wL;             // конструктивная ватерлиния - рабочая осадка
  unsigned **Shell;               // обшивка строится по вершинам треугольников
  unsigned& Ins( int n,int=0 );   // вставка в список, 0 в конец, -l от конца
  Vector InShell( int n, unsigned m ); // номер шпации и отсчет индексной маски
  Vector Select( int n,int k );        // оболочка Shell[0..N+1][1..len]
  Point InSpan( int&,int&,bool=true ); // индексы точки: 0 и Nframes+1 - штевни
  virtual bool KeyBoard( byte );  // краткая справка и методы работы с корпусом
//void FullFree();                // destructor: очистка данных старого корпуса
public:                           // конструктор, авторская метка и обнуление
  Hull();                         // чтение теоретического корпуса и 1-й чертеж
//~Hull(){ FullFree(); }          // здесь освобождается вся оперативная память
  byte Statum;  //   0 - кинематическое позиционирование со скольжением корпуса
                //       над волнением по хордам четырёх точек склона, иначе:
                //   1 - объёмное гравитационное всплытие: борт-киль-вертикаль
                //   2 - гидростатическое давление в волне на смоченной обшивке
                //   3 ÷ ≈ вихреисточники обтекания корпуса набегающим потоком
                //   4 - компоненты скорости на обшивке под волновыми гребнями
                //  ~~ ~ полные потоки в механике отражения волн(в перспективе)
                //  ++ ~ обтекание корпуса с трохоидальными волнами по глубине
                //  ~~ - динамическое изменение тензора инерции и центра масс
                //  ~~ - перепады давления по градиентам поверхности ватерлинии
  unsigned Educt; // = управление выводами результатов мореходного эксперимента
                // 1 - ходкость и отклонение от заданной скорости хода
                // 2 - направление движения и наибольшее рыскание на курсе
                // 4-8-16 - экстремумы вертикальной, бортовой и килевой качки
                // 32-64-128 -вертикальные ускорения на корме, миделе и по носу
                // 512 - 0х200 - признак необходимости записи только превышений
  Hull& Original(); // предустановка гидромеханики вычислительного эксперимента
  Hull& Initial();  // возврат корпуса в исходную позицию по курсу и дифференту
  //
  // геометрия корпуса, состояние движения и маршрутные записи курса и скорости
  //
  Real Length,Breadth,Draught,    // конструктивные длина, ширина и осадка  [м]
       Course,dCs,  // курс корабля и обратное время для полуциркуляции п·dT/30
        Speed,cSp;  // настоящая и устанавливаемая скорость хода корабля  [м/с]
  Vector Locate;    // местоположение корабля для отсчётов волновых полей   [м]
  Flex Route,       // маршрут - траектория контролируемого хода корабля  МБ[м]
       Rate,        // скорости смещения корпуса в корабельном базисе   КБ[м/с]
       Head,Whirl,  // и вращательные движения корпуса в углах Крылова  [р,р/с]
       Mix;         // сохраняемые величины для повторных расчётов в протоколах
                    // Mix.z - уровень моря на миделе; у - курс; x - скорость..
  Hull& Movement();               // движение корпуса под действием внешних сил
  Hull& Floating( bool=false );   // кинематика корабля на морском волнении
 virtual bool Draw();             // виртуальная процедура с настройкой сцены
  Hull& Drawing( byte type=0 );   // 0 ->DrawMode; 1<- корпус; 2<+ профили волн
                                  // прорисовка без настройки графической сцены
  Hull& Get( char* ); // изменение посадки, выбор курса и скорости хода корабля
  Hull& GetDam( char* );// факторы демпфирования поступательной и угловой качки
  Hull& GetExp( char* ); // управление экспериментом и ключи вывода результатов
  Hull& Protocol();      // одна строчка протокола, с сохранением предыстории
                         // true графика или включение перерасчетов
  Hull& Write( int );    // запись + Wavefront Technologies Advanced Visualizer
  char *FileName,*ShipName; // Имя корабля или название исходного проекта UTF-8
  Vector nF,nM, // относительные коэффициенты угловых и поступательных движений
       muF,muM; // обобщённые параметры демпфирования - задаваемые извне [0÷∞[
      // под большими углами крена и до опрокидывания сопротивление утраивается
//private:
  byte DrawMode; // 0 прозрачный корпус с проявлением гидростатических центров
	         // 1 поверхность ватерлинии с контурами штевней и шпангоутов
                 // 2 к действующей ватерлинии добавляется подводные обводы
                 // 3 корпус изображается целиком, но без штевней и шпангоутов
                 // 0х4 те же режимы 0÷3, но только с триангуляционными ребрами
  Hull& Config();      // установка параметров корпуса и методов его прорисовки
  Hull& Contour_Lines();   // отрисовка габаритов и профилей волн на белом фоне
  Hull& DampInit(); // инициализация коэффициентов демпфирования на шаг времени
  //
  //  размерения и динамические параметры корпуса корабля (Volume=0-обновление)
  //  локальная корабельная система координат определяется в составе структуры
  //   Hull::Base и включает координаты пространственного местоположения
  //   Point{X,Y,Z} и тензор тривекторов поворотов Matrix::Vector{x,y,z}
  //
  Real hX,// поперечная метацентрическая высота задаёт аппликату центра тяжести
      Volume,  iV, // исходное водоизмещение, мгновенный погруженный объем V м³
      Surface, iS, // подводная и смоченная поверхность корпуса            S м²
      Floatage,iF, // исходная и действующая площадь ватерлинии            F м²
      sT,          // интервал времени для графиков с кинематикой XYZ-качки сек
      Trim,        // дифферент задается простым смещением центра величины[рад]
      Kv;          // доля сброса отрицательного давления в парадоксе Даламбера
  Vector Ofs,      // внутренние смещения отсчетов по миделю и ватерлинии {x,z}
      Gravity,       // + центр тяжести в локальных корабельных координатах   G
      Buoyancy,vB,   // координаты центра величины,центра объема корпуса     cB
      Floatable,vF,  // центр площади исходной и действующей ватерлинии      cF
      Metacenter,vM, // начальный + текущий поперечные метацентры    в КБ Zm(x)
                 vW, // нормаль интегро-осредненной площади ватерлинии      (δ)
                 vP, // центр внешних давлений, он же - бокового сопротивления
                 dV, // срединная точка к центрам величины и площади ватерлинии
                 vD, // условный центр сосредоточения гидродинамических пар-сил
                 vC, // динамический центр пространственного движения корпуса
                 vS, // накопительный вектор сил от перепада уровня моря  [H/ρ]
                 vR; // поворотный момент от криво-наклонной ватерлинии   [Н·м]
                     // с оценкой мгновенной метацентрической высоты в МБ! h(z)
  Matrix inWater,mW, // моменты инерции площади действующей ватерлинии     I м⁴
         inMass; //,mM; моменты инерции исходного и смещенного корпуса     G м⁴
  void ThreeInitial();// начальная очистка всех величин динамических параметров
  void ThreeFixed();   // обработка всех треугольников, фиксация первой статики
  void Three           //      все элементы одного треугольника обшивки корпуса
     ( int Level,_Vertex,_Vertex,_Vertex );   // в локальном корабельном базисе
  //
  //  локальные процедуры разделения геометрических операций с обшивкой корпуса
  //
  void Triangle( Vertex,Vertex,Vertex );       // обработка одного треугольника
  void divideTriangle(_Vertex,_Real,_Vertex,_Real,_Vertex,_Real );
  void drawTriangle( _Vertex,_Vertex,_Vertex ); //! элементарные треугольничики
  void waterPoints( _Vector,_Vector,_Vector );  // нормали и отрезки ватерлинии
  bool Read( const char *Name,      // чтение исходной таблицы плазовых ординат
            _Real newDraught=0.0 ); //        изменение осадки на перечитывании
  bool LNext( int,unsigned &m,Vector &L,byte*); // левый/кормовой - шпангоут
  bool RNext( int,unsigned &m,Vector &R,byte*); // правый/носовой контур шпации
public:
  Hull& NavigaInform     // общая навигационная информация о волнах с маневрами
         ( Window* );    // картушка морского волнения, курса, скорости корабля
  Hull& wPrint( bool=false ); // информация по кораблю на консоли и в протоколе
};
//
//!  § варианты построения групповых структур трохоидального морского волнения
//
struct Waves:    // пакет групповых структур заданного периода и направления
       Tensor    // с тензорным опорным базисом направления без местоположения
{ const          // где у каждой волны собственные привязки расчетного времени
  char *Title;   // заголовок к идентификации данной волны на графическом поле
  int  Mx,My;    // текущие размерности массивов двумерных волновых полей
  Real // Tw,    // Время относительно волновых фронтов по курсу корабля  [сек]
       Cw,Ow,    // Фазовая скорость и круговая частота бегущей волны [м/с,сˉ¹]
       Ds,       // шаг сетки подбирается под размер волнового бассейна  [метр]
       Wind,     // коэффициент ветрового напряжения на волновых склонах
       Diagonal, // Смещение времени для первого вступления фронта волны  [сек]
       Phase,    // пространственный сдвиг гребней волн в количественной мере
       Length,   // длина собственно трохоидальной волны внутри пакета   [метр]
       Height,   // высота по двум радиусам циклоиды у вершины волны [коэф.0:1]
       Extend;   // протяженность фронта волны меньше для крутого гребня [метр]
protected:       // вычислительный эксперимент задействует интерполяцию по h,v
  Vector **H,    // аппликата и смещение крупных частиц на поверхности жидкости
         **V;    // трехмерное представление векторов поверхностных скоростей
                 //! блок параметров, доступных в производных числовых объектах
public: Waves( const char Name[] );  // конструктор с возможностью перестроения
  //   ~Waves(){}                                    // внешнего ×3× управления
  Waves& Get( char*,Real&,Real&,Real& ); // уточнение характеристик пакета волн
  Waves& Initial(_Real L,_Real H,_Real Dir); // характер и направление волн [м]
  Waves& Clear(); // расчистка всех полей с установкой чистых начальных условий
  Vector Amd( _Vector R );     // интерполяция с учётом дрейфовых сдвигов узлов
  Real   AmH( _Vector A );     // со смежными разностями к ближайшей точке
  Waves& Solving(_Real,_Vector); // ход до Tr по Ts[сек] и прошлый пробег dR[м]
  Waves& View(_Real,int,bool); // изображение групповой структуры трохоидальных
  Waves& Ghost( _Real Tr );   // волн со сдвигом картинки вниз на величину ofsZ
  int Color( _Real mH );     // 256 белосиних оттенков по высоте волн Герстнера
//int Slick( _Point A,_Point B,_Vector N );    // ячейка на воде вблизи корпуса
  Vector Wave( _Real T,_Vector R );// время и местоположение частицы в трохоиде
  void Wave( _Real T, Vector &R, Vector &V );   // место и скорость на трохоиде
//Vector dWave( int y,int x );  // вертикальная скорость частицы на поверхности
private:
  void iWave( _Real X,    // сдвиг-распространение в базисе групповой структуры
            Vector &P,    // локальные координаты внутри моделируемой акватории
            Vector &V );  // скорость частицы в трохоидальной траектории-орбите
  Vector Wave( _Real T,int y,int x );     // +++  в отсчетах сеточных индексов
  Waves& ThreeSurface( _Real Step );      // с проекцией волны на курс корабля
  Waves& ThreeBoundary                    // явная схема для трохоидальных волн
         ( _Real Tr,_Real S,_Real Step ); // экстраполяция и внешнее возмущение
  Waves& FreeSurface( _Real Step );       // ++простое решение в полных потоках
  Waves& FreeBoundary                     // граничные условиями на едином поле
         ( _Real Tr,_Real S,_Real Step );
};
//!  Возмущенная поверхность трохоидальных групповых структур морского волнения
//                                                           friend class Hull;
class Field:       //!  Штормовая акватория из трохоидальных волновых структур
public View        //   - средства визуализации OpenGL и интерфейс управления
{                  //  §1: исходные данные и размерения для морского бассейна
  Event Instant;   //   Начальный отсчет времени при запуске вычислений в целом
  Vector **Ws;     //   Общее волновое поле уровней моря и скоростей течения
//Place Info;      //   Строчка с информацией от таймера справа-внизу окна
public:            //  §2: основные числовые объекты с процессами моделирования
  Real Trun,       //   Отсчет времени завершённого этапа моделирования   [сек]
       Tlaps,      //   Указание отсчета времени продолжения эксперимента [час]
       Long,Wide,  //   Протяженность и ширина модельного бассейна       [метр]
       dS;         //   Собственно шаг сетки по обобщенной поверхности   [метр]
  int mX,mY;       //   Дробление и размерность матрицы получающегося поля волн
  unsigned Kt;     //   Счётчик исполненных шагов вычислительного эксперимента
                   //  §3: предопределение расчетных полей и волновых структур
  Waves Wind,      //   Свежая крутая ветровая волна с обрушающимися гребнями
        Swell,     //   Наиболее интенсивное и ранее сформировавшееся волнение
        Surge;     //   Реликтовое пологое волнение от совсем дальних ураганов
  struct status    //!  Маска настройки режимов вычислительного эксперимента
  { byte wave: 2;  //   0 чистое штилевое море без волнения и ветра
                   //   1 моделирование гидродинамики на теоретическом волнении
                   //   2 простое волновое уравнение с отражением без дисперсии
                   //   3 вычислительная модель трохоидальных волн Герстнера...
                   //   ++ континуально-корпускулярный, полный тензорный подход
    byte peak: 1;  //   0-простое решение в потоках 1-трохоидальные волны {s,z}
    byte draw: 2;  //   0-раскраска 1-контуры 2-с разрядкой 3-волновые профили
    byte view: 2;  //   Тёмная вода в световых оттенках \ светлая с разделением
  } Exp;           //   + прозрачная вода / разделение слоев волновых структур
  //
  //  Раздельная визуализация волновых процессов в независимом графическом окне
  //      расчеты выполняются без обращений к функциям графической визуализации
 virtual bool Draw();    // виртуальная подмена графической сцены + эксперимент
private:
 virtual bool Timer();   // регулярное обновление картинки делается в процедуре
 virtual bool KeyBoard(byte); // справка, управление визуализацией эксперимента
  Field& Simulation();  // моделирование волнения в интервале: от Trun до Tlaps
                        //  ... в режиме прерываний проводить счет нежелательно
  Field& Config();      // интерактивная настройка вычислительного эксперимента
  Field& Get( char* );  // настройка вычислительной акватории и штормовых волн
public:
  Field(_Real,_Real,//_Real, // длина и протяженность гребня, шаг времени [м,°]
         Real, Real, Real,   // ветровые волны с обрушающимися гребнями [м,%,°]
         Real, Real, Real,   // свежая морская зыбь недалеко отшумевших ветров
         Real, Real, Real ); // пологие реликтовые волны от удаленных ураганов
// ~Field(){}               // безусловное(бесконтрольное) завершение программы
  Field& Original( bool );  // начальная (true) и промежуточная=0 предустановка
                            // всего вычислительного эксперимента
   Real Value( Point ); // простая билинейная интерполяция всего волнового поля
 Vector Locas( Point );// дополнение морских координат уровнем поверхности воды
 Vector Wave( _Real T,_Vector R );             // суммарное положение
 Vector WaveV( _Real T,_Vector R,Vector &V ); // точки + скорости

   bool TimeW(){ return Timer(); }

//void Slicks( _Point A,_Point B,_Vector N ) // отражение нормальной компоненты
//{ Wind.Slick( A,B,N ),Swell.Slick( A,B,N ),Surge.Slick( A,B,N ); }// скорости
};
void Model_Config( Window* Win );            // запрос по моделям гидромеханики
void wavePrint();// активная информация по волновым полям для текстовой консоли
bool logTime( bool=true );  // запрос новых отсчётов с протоколируемым временем
void logWave();   // протоколирование состояния групповых структур морских волн
void logMeta();   // протоколирование начальных гидростатических характеристик
void logDamp();   // факторы демпфирования смещений и угловой качки
void logHydro();  // модель гидромеханики качки и ходкости корабля
void logStop();   // завершение протокола
//
// логико-арифметические операции в тригонометрических особенностях из Flex.cpp
//
void e6( Vector &W );         // округление записи для точных сравнений 0.01 мм
void e6( Real &R );
Real& angle( Real &A );                  // -180°÷180°
Real  angle( _Real A,_Real B );          // { A-B: -п÷п }
Vector& angle( Vector &A );
Vector operator ~( _Vector );            // для другого борта
bool intor( _Real F,_Real S,_Real G );   // с включением базовой точки G
bool intoi( _Real F,_Real S,_Real G );   // захват
bool intox( _Real F,_Real S,_Real G );   // и без
Real Inter( _Real x,_Real x0,_Real x1,_Real y0,_Real y1 ); // любое направление
Vector Inter( _Real x, _Real x0,_Real x1, _Vector v0,_Vector v1 );
#endif
