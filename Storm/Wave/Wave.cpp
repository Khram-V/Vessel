//
//	Математические модели настройки вычислительных экспериментов
//	с использованием вертикальных профилей трохоидальных волн
//
//                                           ©2019 ПМ-ПУ СПбГУ, Старый Петергоф
#include <Fenv.h>
#include "Wave.h"    // здесь же и собственно графическая оболочка Window-Place

//const Real
// Long=240.0, // длина мерной мили для визуализации моделируемых профилей  [м]
//   dT=0.125; // изначальный шаг вычислительного эксперимента во времени [сек]
//
//!    Подготовка исходных параметров, начальных и граничных условий
//
Waves::Waves():Window("Моделирование плоской прогрессивной трохоидальной волны",
  Xpm(4),Ypm(36),Xpm(95),Ypm(50) ),Instant(), Tlaps(0.0),Tcalc(0.0),
  dT( 0.1 ),   // изначальный шаг вычислительного эксперимента во времени [сек]
  Long( 480 ), // длина мерной мили для визуализации моделируемых профилей  [м]
  Length( 132.0 ),     // исходная фазовая длина одной трохоидальной волны  [м]
  Rw( 0.95 ),          // относительная высота волны в трохоидальных пропорциях
  Qw( 0 ),             // количество волн в посылке через свободную границу 0→∞
                       //! Поправки к крутизне и направлению ветрового волнения
  Crest( 0.95 ),       //  коэффициент выравнивания среднего уровня моря  [0÷1]
  Wind( .7071 ),       //  условное напряжение ветра по направлению волны [0÷1]
                       //! Подвижная непроницаемая / отражающая граница
//  mB( Long+1 ),      //  Long+1 - нет границы, >< - границы внутри бассейна
//  vB( 0.0 ),         //  скорость перемещения в целых долях от скорости волны
                       //! Контрольно-управляющий блок расчетных параметров
  Kt( 0 ),Kd( 0 )      // Счетчик циклов - признак подготовки начальных условий
{                      // 0-Wave_free, 1-Wave_right, Wave_left, Waves_meet
  Exp.bound=Wave_left; // волна 1-справа; 2-слева; 3-отовсюду и 0-поверхность
  Exp.waves=true;      // тип волны: 0 - длинная или 1 - трохоидальная
  Exp.crest=false;    // процесс: 0 - гармонический; 1 - групповой с дисперсией
  Exp.front=true;    // сглаживание фронта или чистый синус в первом вступлении
  Exp.power=true;    // плюс геометрия/энергия со свойствами групповых структур
   Rw*=1.134*Length/_Pi/4.0;         // исходный радиус трохоиды на поверхности
   Cw=sqrt( 9.8106*Length/_Pd );     // фазовая скорость движения  фронта волны
   Ds=Cw*dT;  // * M_SQRT2 = по диагонали, шаг по критерию устойчивости Куранта
   Nx=Long/Ds;                       // количество  интервалов  расчетной сетки
    V=(Vector*)Allocate( (Nx+1)*sizeof(Vector) ); // очищенная  память к задаче
    H=(Vector*)Allocate( (Nx+1)*sizeof(Vector) ); // о чисто волновых процессах
   dV=(Vector*)Allocate( (Nx+1)*sizeof(Vector) ); // приращение скорости
   dH=(Vector*)Allocate( (Nx+1)*sizeof(Vector) ); //   и дифференциал уровня
    Y=(Vector*)Allocate( (Nx+1)*sizeof(Vector) ); // огибающая групповых
    M=(Vector*)Allocate( (Nx+1)*sizeof(Vector) );// структур прогрессивных волн
    D=(Real*)Allocate( (Nx*2+2)*sizeof(Real) ); // для направления хода волны
    G=(Real*)Allocate( (Nx+1)*sizeof(Real) );  // относительная скорость фронта
// for( int x=0; x<=Nx; x++ )V[x].x=( H[x].x=Long/-2+(Long*x)/Nx )+Ds/2,//                           Y[x].x=( M[x].x=Long/-2+(Long*x)/Nx )+Ds/2; // ++
//  Signs=PlaceOrtho;
                       //! Подвижная непроницаемая / отражающая граница
   wH=Real( Long+1 ),  //  Long+1 - нет границы, >< - границы внутри бассейна
   wV=0.0;             //  скорость перемещения в целых долях от скорости волны


    View_initial();                   // обобщенная настройка графической среды
    glClearColor( 0.9,1,1,0.85 );     // установка общего светло-голубого фона
 // glLoadIdentity();                 // чистая матрица модели на все времена
 // glRotated( -90,1,0,0 );           // замена ординаты аппликатой - на киль
    SetTimer( dT*2000 );              // запуск циклов моделирования по таймеру
    TextInfo();  // и про ход вычислительного эксперимента на текстовой консоли
    glDisable( GL_LIGHTING );
    glPolygonMode( GL_BACK,GL_FILL );
}
void Waves::Initial() // и весь вычислительный эксперимент в исходное состояние
{ for( int i=0; i<=Nx; i++ )V[i]=H[i]=Y[i]=M[i]=dV[i]=dH[i]=0.0;
  Instant.Now(); Tlaps=Tcalc=0.0;
}
//   Проведение вычислительного эксперимента по таймеру в реальном времени
//
bool Waves::Timer()             // картинки готовятся по прерываниям таймера
{ static volatile bool recurse=false,stop=false;
  if( ScanStatus()&CTRL )   // всего вычислительного процесса до повтора <Ctrl>
    { stop=ScanStatus()&SHIFT; Instant=Event()-Tcalc/3600; } else
  if( stop )Instant=Event()-Tcalc/3600; else // Ctrl отпущен, требование полной
  if( !recurse )                 // остановки фиксируется аккордом <Ctrl+Shift>
    { recurse=true;              //! блокировка частых прерываний по таймеру
      Event T;                   // текущее компьютерное время с миллисекундами
      Tlaps=(T-Instant)*3600.0;  // отсчеты времени всего волнового поля  [сек]
      Simulation();  //! собственно вычислительный эксперимент в штормовом море
  //  Drawing();     // выделенная подпрограмма прорисовки одномерной картинки
  //  Save();        // сброс картинки в графический буфер текущего изображения
      recurse=false; Refresh(); // и здесь запрос к перерисовке всей картинки
    } return false;                           // -- иначе всё без изменений
}
int main()
{ feclearexcept( FE_ALL_EXCEPT );
  textsize( 80,24 );
  texttitle
  ( "Отработка трохоидальных волновых профилей - распространение и отражение" );
  Waves Side;    do{ WaitTime( 50 );           // Side.Simulation();
      } while( Side.Ready() && Side.GetKey()!=_Esc );
}
//   Управление вычислительным экспериментом с клавиатуры компьютера
//
Waves& Waves::Config()         // Height = 1.134*Lw*Hw/_Pd/2.0
{ static char Hw[16];          // строчка записи с высотой волны Rw
  static Real R;               // условная амплитуда (радиус)
  static int Q=0;              // количество полных длин волн в пакете на входе
  bool Change=false;           // признак исполненного пересчета
  const char
     *mB[]={ "Свободное море","Волны справа","Волны слева","Волны навстречу" };
  Mlist Menu[]=               // режимы проведения вычислительного эксперимента
  { { 1,0,"  Вычислительный  эксперимент" },{ 2,15 },{ 0,4 }         // 0,1,2
  , { 1,18 }, { 0,11 }, { 1,17 }, { 0,12,"- « применить »" }         // 3,4,5,6
  , { 1,4,"Длина волны%4.0lf",&Length},{0,4," м · %4.2lf",&R},{0,0,Hw} // 7,8,9
  , { 1,6,"%6.3lf",&Crest },{ 0,0,"  заглубление частиц  [0÷1]" }      // 10,11
  , { 1,6,"%6.3lf",&Wind  },{ 0,0,"  ветровое напряжение [0÷1]" }      // 12,13
  };
  if( !Q )Q=!Qw?-3:Qw;
  int ans=-1;
  TextMenu T( Mlist( Menu ),this,-2,-2 );
  while( ans!=_Esc )
  { Mlist &M=Menu[2]; if(Q<=0)M.Msg=" - гармонические ",M.dat=0; else
                              M.Msg=" - группа = %-4d",M.dat=&Q,M.lf=4+('d'<<8);
    Menu[1].Msg=mB[Exp.bound];// действующий режим вычислительного эксперимента
    Menu[3].Msg=Exp.waves?"Трохоидальный процесс":"Длинноволновая модель"; // условия генерации
    Menu[4].Msg=Exp.crest?" с дисперсией":" чистая волна";         //  и модель волнения
    Menu[5].Msg=Exp.front?"Сглаженный фронт ":"Фронт с разрывом "; // первого вступления
    sprintf( Hw," = %3.1f м",Rw );
     R=Rw/( 1.134*Length/_Pd/2 ); ans=T.Answer( ans ); Rw=R*1.134*Length/_Pd/2;
    switch( ans )
    { case 1: Exp.bound++;     Change=true; break;    // выбор типа выхода волн
      case 2: Q=-Q;            Change=true; break;    // количество волн пакета
      case 3: Exp.waves^=true; Change=true; break;    // длинная, трохоидальная
      case 4: Exp.crest^=true; Change=true; break;    // групповые структуры
      case 5: Exp.front^=true; Change=true; break;    // сглаживание фронта
      case _Esc:          if( !Change )break;         // обновление по выходу
      case 6: Change=true;
    } Qw=Q>0?Q:0;
    if( Change ){ Initial(); Change=false; }
  } return *this;
}
bool Waves::KeyBoard( fixed Keyb )
{ const char
   *Name[]={ "Wave","    Моделирование",          // Краткая подсказка по
                    "нестационарной плоской ",    // настройкам и визуализации
                    "  трохоидальной волны",0 },  // →  ←
   *Cmds[]={ "F1  "," эта справка",
             "F2  "," ... ... ",
             "F4  ","настройка эксперимента",0 },
   *Plus[]={ "<Enter> ","отражающая граница",
             "<«—©—»> ","скорость её смещения",
             "<Ctrl+Shift>  ","остановка или",
             "<Ctrl>  ","задержка вычислений",
             "<Space> ","очистка\\сброс",
             "<Esc>/<ctrlC>"," стоп ",0 };
  switch( Keyb )
  { case _F1: Help( Name,Cmds,Plus,-2,-2 ); break;
    case _F4: Config(); break;               // за прос параметров эксперимента
    case _Enter: if( wH>Long )                // четыре режима волнообразования
                { wH=Exp.bound==Waves_meet?0:Long/(Exp.bound==Wave_right?-4:4);
                  wV=0; break; } else
    case _Blank: if( abs( wV )<Eps )wH=Long+1; else wV=0;
                 Initial(); break; // полная очистка и сброс отражающей границы
    case _Left:  wV-=Cw/8; break;
    case _Right: wV+=Cw/8; break;
   default: return false;
  }         return true;
}
