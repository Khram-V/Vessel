//
//	Математические модели настройки вычислительных экспериментов
//	с использованием вертикальных профилей трохоидальных волн
//
//                                           ©2019 ПМ-ПУ СПбГУ, Старый Петергоф
//
#include "Wave.h"               // собственно графическая оболочка Window-Place
//
//     Вычисление текущего смещения точки в пространстве в новом времени
//                       ! условный максимум mH = kW*Omega * Ds*_Pd*Rw/Length
//                       ! волна - полувысота = радиус ++f{Z} ??
//
#if 0
Vector Waves::Wave( _Real Ti, Vector R )  // новое время и место частичкам воды
{
 Real xW=_Pd*(Ti*Cw-R.x-Long/2)/Length,   // дистанция по фазовому отсчету
      Omega=_Pd*Cw/Length;
 Real Xdis=_Pd*(R.x - (Ti*Cw-Long)/2)/Length/GrWave;    // протяженность пакета
  if( xW >= 0.0 )                         // в диагональ дальнего угла бассейна
//if( Xdis <= 0.0 )                       // в диагональ дальнего угла бассейна
  {
    Real Zr = Rw*exp( _Pd*R.z/Length ); //!-- чистый Герстнер без поправок --
//  Real Zr=Rw*exp(_Pd*(R.z+(sin(xW)-1)*Rw)/Length);  //!-- поправка по глубине
    Vector O=R;
    Vector P=Squad( Ti,R ); P.x-=O.x; P=dir( P )/2.0;
//Zr=Rw;

      R.x -= Zr*cos( xW ); //*P.x;
      R.z += Zr*sin( xW ); //*(P.z+1);           //! гармония волны

//      R.x -= Zr*cos( xW + Omega*Ti*-0.5 ); //*P.x;
//      R.z += Zr*sin( xW + Omega*Ti*-0.5 ); //*(P.z+1); //! гармония волны

      R-=O;
//    (R.rotY( -0.5*Omega*Ti )*xW )*=Zr;
      R.rotY( -2*Omega*Ti );
      R+=O;
//    if( Exp.waves )R.x-=X;     // 1- волна трохоидальная; 0- длинная одномерная
  } return R;
}
#else
Vector Waves::Wave( _Real Ti, Vector R )  // новое время и место частичкам воды
{ Real xW=_Pd*(Ti*Cw-R.x-Long/2)/Length,  // дистанция по отсчету волновой фазы
        X=_Pd*Qw;                         //  количество полных фаз на границах
  if( Exp.crest )X*=2.0;                  // с учётом двойного падения скорости
  if( xW >= 0.0 )                         // в диагональ дальнего угла бассейна
  if( !Qw || xW<=X )                      // ограничение пакета излучаемых волн
  { Real Zr = Rw*exp( _Pd*R.z/Length );   //!-- чистый Герстнер без поправок --
  //Real Zr=Rw*exp(_Pd*(R.z+(sin(xW)-1)*Rw)/Length);  //!-- поправка по глубине
    if( !Exp.crest )                      // с дисперсией рушится синхронизация
    if( Crest || Wind )                   // ++ поправки на ветер и подтопление
    { Zr*=exp( _Pd*Zr*( Wind*( sin( xW )-1.0 )      // под косое действие ветра
                 - Crest*cos( xW ) )/Length ); }  // к площади гребня и впадины
    if( Exp.front )   // плавное вступление волны при смещении аргумента на п/2
    { if( (xW-=_Ph)<_Ph )X=Zr*cos(xW)/(2.25-sin(xW)),R.z+=Zr*(1+sin(xW))/2; }
    else
    if( xW<_Ph )X=Zr*sin( 2*xW )/2,R.z+=Zr*(1-cos( 2*xW ))/2; // полфазы гладко
    if( xW>=_Ph )X=Zr*cos( xW ),R.z+=Zr*sin( xW );           //! гармония волны
    if( Exp.waves )R.x-=X;     // 1- волна трохоидальная; 0- длинная одномерная
    else
    { //R.z-=Zr*sin( xW );
      //R.z+=Zr*cos( (2.0*asin( fmod( xW/M_PI+1.0,2.0 )-1.0 )+_Pi) );

//    R.z+=Zr*sin( xW-copysign( pow( fabs( cos( xW ) ),0.1 ),cos( xW ) )/M_PI );
    }
  } return R;                  // возврат исходной частицы с волновым смещением
}
#endif
Vector Waves::Squad( _Real Ti, Vector R ) // огибающая групповой структуры волн
{ Real Xdis = R.x - (Ti*Cw-Long)/2,       // отсчет до границы волнового пакета
       LenS = Length*GrWave/_Pd;          // протяженность пакета группы волн
  if( Xdis <= 0.0 )                       // в диагональ дальнего угла бассейна
  { Real xW=Xdis/LenS;  // контур для пакета энергии с чисто единичным размахом
    Xdis = (1.134/_Pd/2)*Length*exp( R.z/LenS );   // Rw=1.0 без крутых гребней
    if( xW>_Pi/-GrWave )Xdis*=.5-.5*cos( xW*GrWave ); // сглаживание вступления
    R.x-=sin( xW )*Xdis;            // смещение от исходной прямоугольной сетки
    R.z+=cos( xW )*Xdis;  // +Rw)/2 -- двойная высота без нуля в подошве ++Z ??
  } return R;
}
inline void Ftri( Real *A, const int N, int nw ) /// простой треугольный фильтр
{ Real w,W[N]; memcpy( W,A,N*sizeof(Real) );     // =дубль всего числового ряда
  for( int i=0,j,n; i<N; i++ )
  { for( j=0,n=min( nw,N-i ),w=0; j<n; j++ )w+=W[i+j]*(Real(n-j-1)+0.5)/n/n;
    for( j=0,n=min( nw,i+1 ); j<n; j++ )w+=W[i+j-(n-1)]*(Real(j)+0.5)/n/n;
    A[i]=w;                    // w+=W[j+i-nw/2]*(nw-fabs(nw-2*j-0.5))*2/nw/nw;
} }                            //       -- для случая двустороннего осреднения
//  собственно блок построения и визуализации вычислительного эксперимента
//
Waves& Waves::Simulation()
{ Vector A,B,C; int x; bool kDraw=false,inBound=false;
 Real kW=Cw*(dT/=tKrat)/Ds,       // Скорость волны к скорости прохода по сетке      tK=tKrat/(tKrat+1.0),       // граничная поправка однобокого Зоммерфельда      Omega=_Pd*Cw/Length;        //..круговая частота волновых пульсаций [1/с]
  while( Tcalc<=Tlaps+dT )        //  ... расчёты в догонку к реальному времени
  { inBound=fabs( wH )<Long/2-2;  // подвижная граница внутри расчётной области
    if( inBound )wH+=dT*wV;       // сдвиг отражающей границы по скорости хода
            else wH=Long+1;       // исключение воздействия подвижной стенки
    //
    //      излучение прогрессивной компоненты свободной волны
    //      на отрытых границах расчетной области по Зоммерфельду
    //
    dH[0]=kW*tK*(H[1]-H[0]);   // чисто обратный уровень для излучения импульса
    if( Exp.crest )( dH[0]/=2 )-=dT*Omega*(Vector){ H[0].z,0,-H[0].x }/2;
//  if( Exp.crest )H[0].rotY( -0.5*dT*Omega ),dH[0]*=0.5;
    H[0] += dH[0];

    dH[Nx]=kW*tK*(H[Nx-1]-H[Nx]);
    if( Exp.crest )( dH[Nx]/=2 )+=dT*Omega*(Vector){ H[Nx].z,0,-H[Nx].x }/2;
//  if( Exp.crest )H[Nx].rotY( 0.5*dT*Omega ),dH[Nx]*=0.5;
    H[Nx]+=dH[Nx];
    //..
    //!! -- относительная скорость фронта волны
    //
    for( x=0; x<Nx; x++ )G[x]=(dH[x]*H[x]).y / sqr( Rw/( 1.134*Length/_Pd/4 ) )
                                    * _Pd*Cw/Length/3*tKrat/tK; // *dT*Omega
    //
    //     для огибающей группы волн граничное условие излучения попроще
    //
    M[0] +=kW*tK*(M[1]-M[0])/2;                  // пакет волн движется в два
    M[Nx]+=kW*tK*(M[Nx-1]-M[Nx])/2;              // раза медленнее (по энергии)
    //
    //     к результатам добавляются дифференциалы внешних граничных возмущений
    //     по числовому дифференциалу для бегущих волн и их групповой огибающей
    //
    if( Exp.bound&Waves_meet )                 // если есть граничная генерация
    { A=(Vector){ Long/-2,0,0 },               // исходная точка фронта волны
      B=Wave( Tcalc+dT*tK,A )-Wave( Tcalc-dT*tK,A ); // скорость вблизи точки А
      C=Squad( Tcalc+dT*tK,A )-Squad( Tcalc-dT*tK,A ); // уровням и смещениям
      if( Exp.bound&Wave_left  )H[0]+=B,M[0]+=C;   // импульс приращения уровня
      if( Exp.bound&Wave_right )B.x=-B.x,H[Nx]+=B, // и возмущение слева со
                                C.x=-C.x,M[Nx]+=C; // сменой знака абсциссы
    } else
#if 1
    //
    //     и пробный вариант с возмущением всей волновой поверхности
    //
    for( int x=0; x<=Nx; x++ )                     // поверхностное возмущение
    { A=(Vector){ Long/-2+(x*Long)/Nx,0,0 };       // с процессом установления
      B=(Wave(Tcalc+dT/2,A)-Wave(Tcalc-dT/2,A));   // под полным дифференциалом
      H[x] += B * dT*Cw/Ds/4;                      //! попробовать встроить под
//    V[x] -= B; //Cw;                             //  закон управления уровнем
#else
//#pragma omp parallel for
    for( int x=0; x<=Nx; x++ )                     // поверхностное возмущение
    { Real X=Long/-2+(x*Long)/Nx;                  // с процессом установления
      Vector Y=Wave( Tcalc,(Vector){X+Ds/2,0,0} )  // под полным дифференциалом
             - Wav e( Tcalc,(Vector){X-Ds/2,0,0} ); //-(Vector){ Ds,0,0 }; // dH[x].x=-dH[x].x;
    //V[x] += Y * dT*Cw/Ds/8;
    //H[x] -= Y * dT*Cw/Ds/4;
      V[x] += (H[x+1]-H[x]+Y)*dT*Cw/Ds/2;
#endif
    }
    //
    //   вариант простейшей разностной схемы для групповой огибающей
    //
    for( x=1; x<Nx; x++ )        // Динамика смещения узловых точек уровня моря
       M[x]+=( Y[x]-Y[x-1] )*kW/2.0;           // скорость группы вдвое меньшая
    for( x=0; x<Nx; x++ )         // Скорость течений по градиентам уровня моря
       Y[x]+=( M[x+1]-M[x] )*kW/2.0;           // огибающая групповой структуры
    //
    //!        теперь собственно решение волнового уравнения на подвижной сетке
    //                  и для начала простое распространение волн без дисперсии
    //                                   kW=Cw*dT/tKrat/Ds  Omega=_Pd*Cw/Length
    //
    for( x=1; x<Nx; x++ )H[x]-=dH[x]=( V[x]-V[x-1] )*kW/Omega;
    for( x=0; x<Nx; x++ )V[x]-=dV[x]=( H[x+1]-H[x] )*kW*Omega;
    //
    // дисперсионное вращение по радиусу предвычисляемого трохоидального центра
    //                   фазовый поворот для дисперсионного сдвига фронтов волн
    for( x=1; x<Nx; x++ )D[x*2-1]=dir( H[x] )%dir( V[x]+V[x-1] );
    for( x=0; x<Nx; x++ )D[x*2] = dir( V[x] )%dir( H[x]+H[x+1] );
        D[0]=D[1]; D[Nx*2+1]=D[Nx*2]=D[Nx*2-1]=D[Nx*2-2];
/**/    Ftri( D,Nx*2+2,Length/Ds/2 );

    if( Exp.crest )
    {
      for( x=1; x<Nx; x++ )     //! Динамика смещения узловых точек уровня моря
      { Vector &iH=H[x];
        Real d=D[x*2-1]; // if( d<-0.9999 )d=-1; else if( d>0.9999 )d=1; else d=0;
        Real a=d*dT*Omega;
        iH.rotY( a/2 ) += dH[x]*fabs(d)/2;
//      iH += ( dH[x]*d*d + a*(Vector){ iH.z,0,-iH.x } )/2;
//      iH += ( dH[x]*fabs(d)+a*(Vector){ iH.z-iH.x*a/2,0,-iH.x-iH.z*a/2 } )/2;
      }
      for( x=0; x<Nx; x++ )      //! Скорость течений по градиентам уровня моря
      { Vector &iV=V[x];
        Real d=D[x*2]; // if( d<-0.9999 )d=-1; else if( d>0.9999 )d=1; else d=0;
        Real a=d*dT*Omega;
        iV.rotY( a/2 ) += dV[x]*fabs(d)/2;
//      iV += ( dV[x]*d*d + a*(Vector){ iV.z,0,-iV.x } )/2;
//      iV += ( dV[x]*fabs(d)+a*(Vector){ iV.z-iV.x*a/2,0,-iV.x-iV.z*a/2 } )/2;
    } }
    //!  вставка в расчёт подвижной (vW-скорость) отражающей границы (wH-место)    //    if( inBound )                     // для границы внутри расчётной области с    { int ih,iv; Real dh,dv;           // попыткой пересчёта нераздельных ячеек          ih=dh=(wH+Long/2)/Ds;         //   dv,dh: 0÷1
          iv=dv=dh+0.5; dv-=iv; dh-=ih;  // для скорости V и уровня Н
      //
      //!   Вариант с разделением векторных компонент тех же трохоидальных волн
      //    -- возникает небольшое высокочастотное дрожание на отраженной волне
      V[iv].z   = bTwo( V[iv-1].z,wV,dv );
      V[iv+1].z = bTwo( V[iv+2].z,wV,1-dv );
      H[iv+1].z = dv>=0.5 ? iTwo( H[iv-1].z,H[iv].z,2 )
                          : iTwo( H[iv+2].z,H[iv+3].z,-1 );
      H[ih].x   = bTwo( H[ih-1].x,wV*dT,dh );
      H[ih+1].x = bTwo( H[ih+2].x,wV*dT,1-dh );
      V[ih].x   = dh>=0.5 ? iTwo( V[ih-2].x,V[ih-1].x,2 )
                          : iTwo( V[ih+1].x,V[ih+2].x,-1 );
      //!
      dH[iv]=dH[iv+1]=dV[ih]=dV[ih+1]=0.0; // просто для снятия длинных стрелок
    }    // ┌──────────────────────────────────────────────────────────────────────┐
    //!│ в заключение устанавливается новое физическое время для эксперимента │
    // └──────────────────────────────────────────────────────────────────────┘
    ++Kt;                                      // основной счетчик циклов
    Tcalc+=dT;                                 // обновляемое время есть всегда
    kDraw=true;                                // ++ необходимость перерисовки
  }                                            // -- и возврат целого интервала
  dT*=tKrat;               // после кратного уменьшения расчетного шага времени
  if( kDraw )++Kd,Drawing().Save().Show();
  return *this;
}
